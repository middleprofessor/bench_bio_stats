---
title: "linear mixed models simulator"
author: "Jeff Walker"
date: "`r Sys.Date()`"
output: html_document
---
This is the main development code for the GRCBDS simulator. It lives in the Statistics for Experimental Bench Biologists textbook project.

# Setup

```{r setup, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# wrangling packages
library(here) # here makes a project transportable
library(janitor) # clean_names
library(readxl) # read excel, duh!
library(data.table) # magical data frames
library(magrittr) # pipes
library(stringr) # string functions
library(forcats) # factor functions

# analysis packages
library(emmeans) # the workhorse for inference
library(nlme) # gls and some lmm
library(lme4) # linear mixed models
library(lmerTest) # linear mixed model inference
library(afex) # ANOVA linear models
library(glmmTMB) # generalized linear models
library(MASS) # negative binomial and some other functions
library(car) # model checking and ANOVA
library(DHARMa) # model checking
library(mvtnorm)

# graphing packages
library(ggsci) # color palettes
library(ggpubr) # publication quality plots
library(ggforce) # better jitter
library(cowplot) # combine plots
library(knitr) # kable tables
library(kableExtra) # kable_styling tables

# ggplot_the_model.R packages not loaded above
library(insight)
library(lazyWeave)

# use here from the here package
here <- here::here
# use clean_names from the janitor package
clean_names <- janitor::clean_names

# load functions used by this text written by me
# ggplot_the_model.R needs to be in the folder "R"
# if you didn't download this and add to your R folder in your
# project, then this line will cause an error
source_path <- here("R", "ggplot_the_model.R")
source(source_path)

data_folder <- "data"
image_folder <- "images"
output_folder <- "output"
```


```{r lmer_check}
lmer_check <- function(fit){
  return(fit@optinfo$conv$lme4$messages)
}
```

# Simulations to check understanding and pump intuition

```{r simulator_seed_params}
  seed_i = 1
  n_sim = 1
  n_treat = 3 # tau
  n_block = 6 # beta_1, number of blocks
  n_rep =  1 # eta, number of experimental replicates
  n_ss = 1 # epsilon, subsamples within each block:treatment:rep
  n_exp = 1 # number of experiments
  design = "rcbd" # if rcbd, then all treatments within block. If "pseudoreplicated", then single treatment per block and all replicates within block are subsamples.
  unique_id = TRUE
  treatment_crossed_with = "block" # alternat is "rep". If "block" then treatment is applied to block and reps across block:treatment differ. If "rep" then treatment is applied to subblock (the replicate) and reps across block:treatment are same.
  correlated_slopes = "FALSE" # TRUE is random int/slope model to generate data
  beta = c(10, 0, 0) # effects
  gamma = c(0.5, 0.5) # sd of random intercept and slopes for non-ref
  rho = c(0.6, 0.6, 0.0) # r between random intercept and slopes
  sigma_exp = 0 # sd among experiments
  sigma_exp.block = 1 # sd among exp:blocks (or blocks if n_exp = 1)
  sigma_exp.treat = 0 # sd among exp:treat (or blocks:treat if n_exp = 1)
  sigma_exp.block.treat = c(0.5, 0.5, 0.5)
  sigma_rep = 0 # sd among experimental replicates of treatment:block
  sigma_ss = 0.5 # sd among subsamples within replication of treatment:block
  equal_n = TRUE
  exp_name = "exp"
  block_name = "block"
  rep_name = "rep"
  ss_name = "ss"
```

```{r simulator}
# this is the official simulator function. Any changes should be copied into ggplot_the_model.Rmd for compilation
simulator <- function(
  seed_i = 1,
  n_sim = 1,
  family = "gaussian",
  n_treat = 3, # tau
  n_block = 6, # beta_1, number of (nested) blocks
  n_rep = 1, # eta, number of experimental replicates
  n_ss = 1, # epsilon, number of subsamples within each block:treatment.
  n_exp = 1, # number of experiments
  design = "rcbd", # if rcbd, then all treatments within block. If "pseudoreplicated", then single treatment per block and all replicates within block are subsamples.
  unique_id = TRUE, # give unique ids to values of all factors
  treatment_crossed_with = "block", # not used. alternat is "rep". If "block" then treatment is applied to block and reps across block:treatment differ. If "rep" then treatment is applied to subblock (the replicate) and reps across block:treatment are same. This makes "rep" a block nested within "block"
  correlated_slopes = FALSE, # TRUE uses random int/slope model to generate data
  beta = c(10, 0, 0), # effects
  gamma = c(0.5, 0.5), # sd of random intercept and slopes for non-ref
  rho = c(0.6, 0.6, 0.6), # r between random intercept and slopes
  sigma_exp = 0, # sd among experiments
  sigma_exp.block = 1, # sd among exp:block (or block if n_exp = 1)
  sigma_exp.treat = 0, # sd among exp:treat
  sigma_exp.block.treat = c(0), # sd among exp:block:treat, this can be a vector
  # (or block:treat if n_exp = 1). If not a vector, then vector created with value for each treatment. This creates heterogeneity of correlation
  sigma_rep = 0, # sd among experimental replicates of treatment:block
  sigma_ss = 0.3, # sd among subsamples within replication of treatment:block. This is just sigma
  equal_n = TRUE,
  group_names = NULL,
  exp_name = "exp",
  block_name = "block",
  rep_name = "rep",
  ss_name = "ss"
){
  # 1. default beta is for n_treat = 2. If > 2 then default adds 0 for each added level
  # 2. default sigma is 1 for all treatment levels. Can specify heterogeneity by sending vector with sigma for each level of treatment
  # 3. if correlated_slopes = TRUE, then default gamma c(0.5, 0.5) is sd for intercept (first element) and same slope (2nd element) for all non-reference levels. Can specify detail by sending vector with value for intercept in cell one and non-reference slopes in all other cells.
  #  if correlated_slopes = FALSE, then default gamma c(0.5, 0.5) is sd for block (first element) and treatment:block combinations (2nd element).
  # 4. default rho is 0.6 for all correlations between intercept and slopes and between slopes. Can specify by sending vector equivalent to lower triangular of correlation matrix
  if(design == "pseudoreplicated"){
      correlated_slopes <- FALSE
  }
  if(n_treat > 2 & length(beta) == 2){# fill out beta
    beta <- c(beta, rep(0, n_treat-2))
  }
  if(length(sigma_exp.block.treat) == 1){#
    sigma_exp.block.treat <- rep(sigma_exp.block.treat, n_treat)
  }
  if(length(gamma) == 2 &
     design == "rcbd" &
     correlated_slopes == TRUE &
     n_treat > 2){# fill out gamma
    gamma <- c(gamma[1], rep(gamma[2], (n_treat - 1)))
  }
  if(length(rho) == 1){# fill out rho
    rho <- rep(rho, n_treat*(n_treat-1)/2)
  }
  if(length(sigma_ss) == 1){# fill out rho
    sigma_ss <- rep(sigma_ss, n_treat)
  }
  
  
  N_reps <- n_block * n_treat * n_rep * n_exp
  N <- N_reps * n_ss
  # returns N by n_sim matrix of fake data. Each sim is in its own column. The first two columns are treatment and block 
  if(is.null(group_names)){
    treatment_levels <- c("Cn", "Tr1", "Tr2", "Tr3")[1:n_treat]
  }else{
    treatment_levels <- c(group_names)[1:n_treat]
  }
  

  # if reps in blocks are experimental
  if(design == "rcbd"){
    exp_levels <- paste0(exp_name,
                          sprintf("%02d", 1:n_exp))
    block_levels <- paste0(block_name,
                          sprintf("%02d", 1:n_block))
    block.treat <- do.call(paste, expand.grid(block_levels,
                                              treatment_levels))
    rep_levels <- paste0(rep_name,
                         sprintf("%02d", 1:n_rep))
  }
  # if reps in blocks are technical
  if(design == "pseudoreplicated"){
    if(n_block == 1){
      block_levels <- paste0(block_name,
                             sprintf("%02d", 1:n_block))
    }else{
      block_levels <- paste0(block_name,
                             sprintf("%02d", 1:(n_block*n_treat)))
    }
      exp_levels <- paste0(exp_name,
                           sprintf("%02d", 1:n_exp))
      block.treat = paste(rep(block_levels, each = n_treat),
                          treatment_levels)
      rep_levels <- paste0(rep_name,
                           sprintf("%02d", 1:n_rep))
  }   
  ss_levels <- paste0(ss_name,
                      sprintf("%02d", 1:n_ss))
  groups <- do.call(paste, expand.grid(exp_levels,
                                       block.treat,
                                       rep_levels,
                                       ss_levels
                                       ))
  fake_data_all <- data.table(NULL)
  fake_data_all[, c("exp", "block", "treatment", "rep", "ss") :=
                  tstrsplit(groups, " ", fixed = TRUE)]
  setorder(fake_data_all, exp, block, treatment, rep, ss)
  
  if(unique_id == TRUE){
    fake_data_all[, exp_id := paste(
      exp_name,
      sprintf("%02d",
              as.integer(factor(exp))),
      sep = "_")]
    fake_data_all[, block_id := paste(
      block_name,
      sprintf("%02d",
              as.integer(factor(paste(exp, block)))),
      sep = "_")]
    fake_data_all[, rep_id := paste(
      rep_name,
      sprintf("%02d",
              as.integer(factor(paste(block_id, treatment, rep)))),
      sep = "_")]
    fake_data_all[, ss_id := paste(
      ss_name,
      sprintf("%03d",
              as.integer(factor(paste(rep_id, ss)))),
      sep = "_")]
  }

  # make specific to experiment
  if(exp_name != "exp"){
    setnames(fake_data_all, "exp_id", exp_name)
  }
  if(block_name != "block"){
    setnames(fake_data_all, "block_id", block_name)
  }
  if(rep_name != "rep"){
    setnames(fake_data_all, "rep_id", rep_name)
  }
  if(ss_name != "ss"){
    setnames(fake_data_all, "ss_id", ss_name)
  }

  # order factor levels
  fake_data_all[, treatment := factor(treatment,
                                      levels = treatment_levels)]
  
  # random component
  # random variance matrix
  # gamma[1] is std of random intercept u_0
  # gamma[2] is std of random slope for first non-reference
  #     treatment level
  # gamma[3] is std of random slope for second non-reference
  #     treatment level
  # and so on
  if(correlated_slopes == TRUE){
    L <- diag(gamma)
    Psi_R <- diag(length(gamma))
    Psi_R[lower.tri(Psi_R, diag = FALSE)] <- rho
    Psi_R <- t(Psi_R)
    Psi_R[lower.tri(Psi_R, diag = FALSE)] <- rho
    Psi <- L%*%Psi_R%*%L
  }
  
  fd_mat <- matrix(as.numeric(NA), nrow = N, ncol = n_sim)
  colnames(fd_mat) <- paste0("sim_", 1:n_sim)
  # View(fake_data_all)
  for(sim_i in 1:n_sim){
    seed_i <- seed_i + 1
    sim_seed <- seed_i
    set.seed(sim_seed)
    
    # fixed component
    X <- model.matrix(~ treatment,
                      data = fake_data_all)
    y_fixed <- (X %*% beta)[,1]
    
    # random coefficients
    # matrix of correlated coefficients with
    # n_block (number of block) rows, and
    # n_rand (number of random effects) columns
    
    if(design == "rcbd"){# replicates within blocks are experimental reps
      if(correlated_slopes == TRUE){
        # random intercepts and slopes
        # assumes correlation between slopes and intercepts
        # Z <- model.matrix(~ 0 + block + block:treatment, data = fake_data_all)
        # this generates combination columns for non-reference treatment levels
        Z1 <- model.matrix(~ 0 + block +
                             block:treatment,
                           data = fake_data_all)
        # random effects (coefficients)
        # cols are gamma0, gamma1, ...
        # rows are block
        u_mat <- rmvnorm(n_block,
                         sigma = Psi)
        # flattened to a vector, order is
        # g0 for id1..k, then
        # g1 for id1..k, then...
        u1 <- c(u_mat)
      }else{ #if random intercept interaction model
        if(n_exp > 1){ # nested
          Z1a <- model.matrix(~ 0 + exp, data = fake_data_all)
          Z1b <- model.matrix(~ 0 + exp:treatment, data = fake_data_all)
          Z1c <- model.matrix(~ 0 + exp:block, data = fake_data_all)
          Z1d <- model.matrix(~ 0 + exp:block:treatment,
                              data = fake_data_all)
          Z1 <- cbind(Z1a, Z1b, Z1c, Z1d)
          u1 <- c(rnorm(n_exp, mean = 0, sd = sigma_exp),
                  rnorm(n_exp*n_treat, mean = 0, sd = sigma_exp.treat),
                  rnorm(n_exp*n_block, mean = 0, sd = sigma_exp.block),
                  rnorm(n_exp*n_block*n_treat, mean = 0,
                        sd = sigma_exp.block.treat))
        }
        if(n_exp == 1){
          # random block:treatment intercept
          # block:treatment intercept intercept functions as slope
          # and is independent of block intercept
          # this generates combination columns for *all* treatment levels
          # differs from random intercept and slope which only generates
          # slope coefs for non ref levels
          Z1a <- model.matrix(~ 0 + block, data = fake_data_all)
          Z1b <- model.matrix(~ 0 + block:treatment, data = fake_data_all)
          Z1 <- cbind(Z1a, Z1b)
          u1 <- c(rnorm(n_block, mean = 0,
                        sd = sigma_exp.block),
                  rnorm(n_block*n_treat, mean = 0,
                        sd = rep(sigma_exp.block.treat, each = n_block)))          
        }
      }
    }
    if(design == "pseudoreplicated"){# replicates within block:treatment are technical reps
      # random nested intercept
      fake_data_all[, batch := paste0("batch_", as.integer(as.factor(paste(exp, block, treatment, rep))))]
#      Z1 <- model.matrix(~ 0 + rep_id, data = fake_data_all)
      Z1 <- model.matrix(~ 0 + batch, data = fake_data_all)
      u1 <- rnorm(N_reps, mean = 0, sd = sigma_rep)
    }
    
    # random intercepts for replicated block:treatment
    # if there is no subsampling within replicate, then these columns are not 
    # in the specified model (because only one measure of each
    # block:treatment:experiment combo) - that is, these columns
    # collapse and add to the residual = subsampled error
    # ijk - ith treatment, jth block, kth replicate
    if(design == "rcbd"){
      # if n_exp == 1 then cannot add exp to combination
      # if n_rep == 1 then cannot add rep to combination
      if(n_rep == 1 & n_exp == 1){
        Z2 <- model.matrix(~ 0 + block:treatment,
                           data = fake_data_all)
        colnames(Z2) <- paste0(colnames(Z2), ":rep_1")
      }
      if(n_rep == 1 & n_exp > 1){
        Z2 <- model.matrix(~ 0 + exp:block:treatment,
                           data = fake_data_all)
        colnames(Z2) <- paste0(colnames(Z2), ":rep_1")
      }
      if(n_rep > 1 & n_exp == 1){
          Z2 <- model.matrix(~ 0 + block:treatment:rep,
                             data = fake_data_all)
        }
      if(n_rep > 1 & n_exp > 1){
          Z2 <- model.matrix(~ 0 + exp:block:treatment:rep,
                             data = fake_data_all)
        }
    }else{
      Z2 <- NULL
    }

    # add random block:treatment:rep intercepts
    if(design == "rcbd"){
      u2 <- rnorm(N_reps, mean = 0, sd = sigma_rep)
    }else{
      u2 <- NULL
    }
    
    # random intercepts for subsampling within replicates = n_rep * n_treat * n_block
    # ijkm ith treatment, jth block, kth replicate, mth subsample
    # this is just the residual error so don't need coefficients

    u <- c(u1, u2)
    
    # put it all together
    Z <- cbind(Z1, Z2)
    
    # check!
    # colnames(Z) <- 1:ncol(Z)
    # head(cbind(fake_data_all[,1:3], Z))
    # u_mat
    # u
    
    # double check!
    # fake_y <- rnorm(nrow(fake_data_all))
    # lForm <- lFormula(fake_y ~ treatment + (treatment | block),
    #                   fake_data_all)    # lme4's function to process a model formula
    # Z1 <- t(as.matrix(lForm$reTrms$Zt))
    # u1 <- t(c(t(u_mat)))[1,]
    # y_rand2 <- (Z1 %*% u1)[,1]
    if(family == "gaussian"){
      e_ss <- rnorm(N, mean = 0, sd = sigma_ss[1])
      y_rand <- (Z %*% u)[,1] + e_ss
      y <- y_fixed + y_rand
    }
    if(family == "nbinom"){
      y_rand <- (Z %*% u)[,1]
      mu_sim <- y_fixed + y_rand
      mu_bar <- mean(mu_sim)
      # p = mu/sigma^2
      # r = mu^2/(sigma^2 - mu)
      # sigma^2 = mu + mu^2/theta
      # theta <- mu^2/(sigma^2 - mu)
      # theta = r
      theta_sim <- mu_bar^2/(sigma_ss[1]^2 - mu_bar)
      y <- rnegbin(N, mu = mu_sim, theta = theta_sim)
    }
     if(family == "gamma"){
      y_rand <- (Z %*% u)[,1]
      mu_sim <- y_fixed + y_rand
      mu_bar <- mean(mu_sim)
      # k = shape, theta = scale
      # mean = k * theta
      # sigma^2 = k * theta^2
      # mean/theta = sigma^2/theta^2
      # theta^2*mean/theta = sigma^2
      # theta = sigma^2/mean
      # theta^2 = mean^2/k^2
      # theta^2 = sigma^2/k
      # mean^2/k^2 = sigma^2/k
      # mean^2/sigma^2 = k^2/k
      # mean^2/sigma^2 = k
      k_sim <- mu_bar^2/sigma_ss[1]^2 # constant shape
      theta_sim <- mu_sim/k_sim # variable scale depending on mu
      y <- rgamma(N, shape = k_sim, scale = theta_sim)
    }
   
    fd_mat[, sim_i] <- y
  }
  fake_data_all <- cbind(fake_data_all,
                         fd_mat)
  return(fake_data_all)
}
```

```{r safelme, echo=FALSE, eval=FALSE}
safelme <- safely(lme, otherwise = NA)
```

```{r lmer-check, echo=FALSE}
lmer_check <- function(fit){
  return(fit@optinfo$conv$lme4$messages)
}
```

```{r explore-simulator, echo=FALSE, eval=FALSE}
#seed_starter <- 1
seed_starter <- seed_starter + 1
fake_grcbd <- simulator(
  seed_i = seed_starter,
  n_sim = 1,
  n_treat = 3, # number of treatment levels
  n_block = 1000, # number of litters (blocks)
  n_rep = 5, # number of mice per litter:treatment
  n_ss = 1, # number of subsamples
  design = "rcbd",
  correlated_slopes = FALSE, # TRUE uses random int/slope model to generate data
  beta = c(10, 0,0),
  gamma = c(1,1, 0), # sd of random intercept and slopes for non-ref
  rho = 0.0, # r between random intercept and slopes
  sigma_exp = 0, # sd among experiments
  sigma_exp.block = 0.1, # sd among exp:block (or block if n_exp = 1)
  sigma_exp.treat = 0, # sd among exp:treat
  sigma_exp.block.treat = c(.1, 0.1, 0.1), # sd among exp:block:treat
  sigma_rep = 0.1,
  sigma_ss = 1, # sd among subsamples within replication of treatment:block
  block_name = "experiment",
  rep_name = "mouse",
  ss_name = "ss"
)

m1 <- lm(sim_1 ~ treatment, data = fake_grcbd)
fake_grcbd[, glucose_residual := residuals(m1)]
y_cols <- c("Cn", "Tr1", "Tr2")
fake_grcbd_wide <- dcast(fake_grcbd,
                        experiment + rep ~ treatment,
                        value.var = "glucose_residual")
cov(fake_grcbd_wide[, .SD, .SDcols = y_cols]) %>%
  kable(digits = 3,
        caption = "Covariance matrix of residuals") %>%
  kable_styling(full_width = FALSE)
cor(fake_grcbd_wide[, .SD, .SDcols = y_cols]) %>%
  kable(digits = 3,
        caption = "Covariance matrix of residuals") %>%
  kable_styling(full_width = FALSE)

```

```{r pairwise_t_test}
# need to generalize this

pairwise_t_tests <- function(
    y_col, # response column
    g_col, # grouping column
    id_col = NULL, # id column for paired t
    paired = TRUE,
    method = "revpairwise",
    data){
  
 
  
  g_levels <- levels(fake_rcbd[, as.factor(get(g_col))])
  n_groups <- length(g_levels)
  
  # take subsample means, if these exist
  dt_long <- data[, .(y = mean(get(y_col))),
                  by = .(get(g_col), get(id_col))]
  setnames(dt_long, old = names(dt_long), new = c(g_col, id_col, y_col))
  
  # cast t wide with each ID as separate column
  dt_wide <- dcast(dt_long,
                   formula(paste(id_col, g_col, sep = "~")),
                   value.var = y_col)

  # create unpopulated output table in style of emmeans contrast table
  n_comparisons <- n_groups * (n_groups - 1) / 2

  l <- 0
  ttest_contrast <- data.table(NULL)
  for(i in 2:n_groups){
    for(j in 1:(i-1)){
      l <- l+1
      if(method == "revpairwise"){
        group_1 <- g_levels[i]
        group_2 <- g_levels[j]
        ttest_ij <- t.test(dt_wide[, get(group_1)],
                           dt_wide[, get(group_2)],
                           paired = TRUE,
                           na.action = "na.omit")
      }
      if(method == "pairwise"){
        group_1 <- g_levels[j]
        group_2 <- g_levels[i]
        ttest_ij <- t.test(dt_wide[, get(group_1)],
                           dt_wide[, get(group_2)],
                           paired = TRUE,
                           na.action = "na.omit")
      }
      ttest_contrast <- rbind(ttest_contrast,
                              data.table(
                                contrast = paste(group_1, group_2, sep = "-"),
                                 estimate = ttest_ij$estimate,
                                SE = ttest_ij$estimate / ttest_ij$statistic,
                                df = ttest_ij$parameter,
                                lower.CL = ttest_ij$conf.int[1],
                                upper.CL = ttest_ij$conf.int[2],
                                t.ratio = ttest_ij$statistic,
                                p.value = ttest_ij$p.value
                              ))
      
    }
  }
  

  return(ttest_contrast)
}

```

## CRDS

```{r fake_crds}
set.seed(1)
fake_crds <- simulator(
  seed_i = 1,
  n_sim = 1,
  n_treat = 3, # number of treatment levels
  n_block = 1, # number of litters (blocks)
  n_rep = 6, # number of mice per litter:treatment
  n_ss = 5, # number of subsamples
  n_exp = 1, # number of experiments
  design = "pseudoreplicated",
  correlated_slopes = TRUE, # TRUE uses random int/slope model to generate data
  beta = c(10, 1, -0.5),
  block_name = "litter",
  rep_name = "mouse",
  ss_name = "ss"
)

```

### balanced

All models have same statistics.

```{r fake_crds-balanced, warning=FALSE, message = FALSE}
# models
lmm1 <- lmer(sim_1 ~ treatment + (1 | mouse),
              data = fake_crds)

aov1 <- aov_4(sim_1 ~ treatment + (1 | mouse),
              data = fake_crds)

fake_crds_means <- fake_crds[, .(sim_1 = mean(sim_1)),
                             by = .(treatment, mouse)]
lm1 <- lm(sim_1 ~ treatment,
              data = fake_crds_means)

# contrasts
lmm1_pairs <- emmeans(lmm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov1_pairs <- emmeans(aov1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lm1_pairs <- emmeans(lm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)

# report
table_dt <- rbind(lmm1_pairs,
                  aov1_pairs,
                  lm1_pairs)

table_dt %>%
  kable(digits = c(1, 3, 3, 3, 3, 3, 3, 4), caption = "models") %>%
  kable_styling() %>%
  pack_rows("lmm1 - random intercept", 1, 3) %>%
  pack_rows("aov1 - ANOVA", 4, 6) %>%
  pack_rows("lm1 - lm on means", 7, 9)
```

### unbalanced

mouse 1 deleted has no consequence. All models have same statistics.

```{r fake_crds_unbalanced, warning=FALSE, message=FALSE}
fake_crds_missing <- fake_crds[batch != "batch_1"]

# models

lmm1 <- lmer(sim_1 ~ treatment + (1 | mouse),
              data = fake_crds_missing)

aov1 <- aov_4(sim_1 ~ treatment + (1 | mouse),
              data = fake_crds_missing)

fake_crds_means <- fake_crds_missing[, .(sim_1 = mean(sim_1)),
                             by = .(treatment, mouse)]
lm1 <- lm(sim_1 ~ treatment,
              data = fake_crds_means)

lmm1_pairs <- emmeans(lmm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov1_pairs <- emmeans(aov1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lm1_pairs <- emmeans(lm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)


table_dt <- rbind(lmm1_pairs,
                  aov1_pairs,
                  lm1_pairs)

table_dt %>%
  kable(digits = c(1, 3, 3, 3, 3, 3, 3, 4), caption = "models") %>%
  kable_styling() %>%
  pack_rows("lmm1 - random intercept", 1, 3) %>%
  pack_rows("aov1 - ANOVA", 4, 6) %>%
  pack_rows("lm1 - lm on means", 7, 9)
```

## RCBD

1. 2 treatments, equal variance

```{r seed_starter}
seed_starter <- 0
```

```{r fake_rcbd-2-treats-balanced}
seed_starter <- seed_starter + 1
fake_rcbd <- simulator(
  seed_i = seed_starter,
  n_treat = 2, # number of treatment levels
  n_block = 10, # number of litters (blocks)
  n_ss = 1, # number of subsamples
  design = "rcbd",
  beta = c(10, 1),
  sigma_exp.block = 1, # sd among exp:block (or block if n_exp = 1)
  sigma_exp.block.treat = c(0), # sd among exp:block:treat
  sigma_ss = 0.5, # sd among subsamples within replication of treatment:block
  block_name = "litter",
  rep_name = "mouse",
  ss_name = "ss"
)

lmm1 <- lmer(sim_1 ~ treatment + (1 | block),
              data = fake_rcbd)

lmm2 <- lme(sim_1 ~ treatment,
            random = ~1 | block,
            correlation = corSymm(form = ~ 1 | block),
            weights = varIdent(form = ~ 1 | treatment),
              data = fake_rcbd)
            
aov1 <- aov_4(sim_1 ~ treatment + (treatment | block),
              data = fake_rcbd)
aov2 <- aov_4(sim_1 ~ treatment + (treatment | block),
           include_aov = TRUE,
              data = fake_rcbd)

lm1 <- lm(sim_1 ~ treatment + block,
              data = fake_rcbd)
ttest1_pairs <- pairwise_t_tests(y_col = "sim_1",
                           g_col = "treatment",
                           id_col = "litter",
                           data = fake_rcbd)

# contrasts
lmm1_pairs <- emmeans(lmm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm2_pairs <- emmeans(lmm2, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov1_pairs <- emmeans(aov1, specs = "treatment", model = "multivariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov2_pairs <- emmeans(aov2, specs = "treatment", model = "univariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lm1_pairs <- emmeans(lm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)


table_dt <- rbind(lmm1_pairs,
                  lmm2_pairs,
                  aov1_pairs,
                  aov2_pairs,
                  lm1_pairs,
                  ttest1_pairs)

table_dt %>%
  kable(digits = c(1, 3, 3, 3, 3, 3, 3, 4), caption = "models") %>%
  kable_styling() %>%
  pack_rows("lmm1 - random intercept", 1, 1) %>%
  pack_rows("lmm2 - heterogenous variance", 2, 2) %>%
  pack_rows("aov1 - multivariate RM ANOVA", 3, 3) %>%
  pack_rows("aov2 - univariate RM ANOVA", 4, 4) %>%
  pack_rows("lm1 - additive lm", 5, 5) %>%
  pack_rows("ttest1 - paired t", 6, 6)

```

unbalanced

```{r fake-rcbd-2-treats-unbalanced}
seed_starter <- seed_starter + 1
fake_rcbd <- simulator(
  seed_i = seed_starter,
  n_treat = 2, # number of treatment levels
  n_block = 10, # number of litters (blocks)
  n_ss = 1, # number of subsamples
  design = "rcbd",
  beta = c(10, 1),
  sigma_exp.block = 1, # sd among exp:block (or block if n_exp = 1)
  sigma_exp.block.treat = c(0), # sd among exp:block:treat
  sigma_ss = 0.5, # sd among subsamples within replication of treatment:block
  block_name = "litter",
  rep_name = "mouse",
  ss_name = "ss"
)
fake_rcbd <- fake_rcbd[-c(1), ]
# fake_rcbd <- fake_rcbd[-c(1, 3), ]
lmm1 <- lmer(sim_1 ~ treatment + (1 | block),
              data = fake_rcbd)

lmm2 <- lme(sim_1 ~ treatment,
            random = ~1 | block,
            correlation = corSymm(form = ~ 1 | block),
            weights = varIdent(form = ~ 1 | treatment),
              data = fake_rcbd)
            
aov1 <- aov_4(sim_1 ~ treatment + (treatment | block),
              data = fake_rcbd)
aov2 <- aov_4(sim_1 ~ treatment + (treatment | block),
           include_aov = TRUE,
              data = fake_rcbd)

lm1 <- lm(sim_1 ~ treatment + block,
              data = fake_rcbd)
ttest1_pairs <- pairwise_t_tests(y_col = "sim_1",
                           g_col = "treatment",
                           id_col = "litter",
                           data = fake_rcbd)

# contrasts
lmm1_pairs <- emmeans(lmm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm2_pairs <- emmeans(lmm2, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov1_pairs <- emmeans(aov1, specs = "treatment", model = "multivariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov2_pairs <- emmeans(aov2, specs = "treatment", model = "univariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lm1_pairs <- emmeans(lm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)


table_dt <- rbind(lmm1_pairs,
                  lmm2_pairs,
                  aov1_pairs,
                  aov2_pairs,
                  lm1_pairs,
                  ttest1_pairs)

table_dt %>%
  kable(digits = c(1, 3, 3, 3, 3, 3, 3, 4), caption = "models") %>%
  kable_styling() %>%
  pack_rows("lmm1 - random intercept", 1, 1) %>%
  pack_rows("lmm2 - heterogenous variance", 2, 2) %>%
  pack_rows("aov1 - multivariate RM ANOVA", 3, 3) %>%
  pack_rows("aov2 - univariate RM ANOVA", 4, 4) %>%
  pack_rows("lm1 - additive lm", 5, 5) %>%
  pack_rows("ttest1 - paired t", 6, 6)
```

balanced with heterogeneity

```{r fake_rcbd-2-treats-hetero}
seed_starter <- seed_starter + 1
fake_rcbd <- simulator(
  seed_i = seed_starter,
  n_treat = 2, # number of treatment levels
  n_block = 10, # number of litters (blocks)
  n_ss = 1, # number of subsamples
  design = "rcbd",
  beta = c(10, 1),
  sigma_exp.block = 1, # sd among exp:block (or block if n_exp = 1)
  sigma_exp.block.treat = c(0.5), # sd among exp:block:treat
  sigma_ss = 0.5, # sd among subsamples within replication of treatment:block
  block_name = "litter",
  rep_name = "mouse",
  ss_name = "ss"
)

lmm1 <- lmer(sim_1 ~ treatment + (1 | block),
              data = fake_rcbd)

lmm2 <- lme(sim_1 ~ treatment,
            random = ~1 | block,
            correlation = corSymm(form = ~ 1 | block),
            weights = varIdent(form = ~ 1 | treatment),
              data = fake_rcbd)
            
aov1 <- aov_4(sim_1 ~ treatment + (treatment | block),
              data = fake_rcbd)
aov2 <- aov_4(sim_1 ~ treatment + (treatment | block),
           include_aov = TRUE,
              data = fake_rcbd)

lm1 <- lm(sim_1 ~ treatment + block,
              data = fake_rcbd)
ttest1_pairs <- pairwise_t_tests(y_col = "sim_1",
                           g_col = "treatment",
                           id_col = "litter",
                           data = fake_rcbd)

# contrasts
lmm1_pairs <- emmeans(lmm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm2_pairs <- emmeans(lmm2, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov1_pairs <- emmeans(aov1, specs = "treatment", model = "multivariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov2_pairs <- emmeans(aov2, specs = "treatment", model = "univariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lm1_pairs <- emmeans(lm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)


table_dt <- rbind(lmm1_pairs,
                  lmm2_pairs,
                  aov1_pairs,
                  aov2_pairs,
                  lm1_pairs,
                  ttest1_pairs)

table_dt %>%
  kable(digits = c(1, 3, 3, 3, 3, 3, 3, 4), caption = "models") %>%
  kable_styling() %>%
  pack_rows("lmm1 - random intercept", 1, 1) %>%
  pack_rows("lmm2 - heterogenous variance", 2, 2) %>%
  pack_rows("aov1 - multivariate RM ANOVA", 3, 3) %>%
  pack_rows("aov2 - univariate RM ANOVA", 4, 4) %>%
  pack_rows("lm1 - additive lm", 5, 5) %>%
  pack_rows("ttest1 - paired t", 6, 6)

```

```{r fake_rcbd-3-treatments-balanced}
seed_starter <- seed_starter + 1
fake_rcbd <- simulator(
  seed_i = seed_starter,
  n_treat = 3, # number of treatment levels
  n_block = 10, # number of litters (blocks)
  n_ss = 1, # number of subsamples
  design = "rcbd",
  beta = c(10, 1, 0.5),
  sigma_exp.block = 1, # sd among exp:block (or block if n_exp = 1)
  sigma_ss = 0.8, # sd among subsamples within replication of treatment:block
  block_name = "litter",
  rep_name = "mouse",
  ss_name = "ss"
)

# models
lmm1 <- lmer(sim_1 ~ treatment + (1 | block),
              data = fake_rcbd)

lmm2 <- lme(sim_1 ~ treatment,
            random = ~1 | block,
            correlation = corSymm(form = ~ 1 | block),
            weights = varIdent(form = ~ 1 | treatment),
              data = fake_rcbd)
            
aov1 <- aov_4(sim_1 ~ treatment + (treatment | block),
              data = fake_rcbd)
aov2 <- aov_4(sim_1 ~ treatment + (treatment | block),
           include_aov = TRUE,
              data = fake_rcbd)

lm1 <- lm(sim_1 ~ treatment + block,
              data = fake_rcbd)
ttest1_pairs <- pairwise_t_tests(y_col = "sim_1",
                           g_col = "treatment",
                           id_col = "litter",
                           data = fake_rcbd)

# contrasts
lmm1_pairs <- emmeans(lmm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm2_pairs <- emmeans(lmm2, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov1_pairs <- emmeans(aov1, specs = "treatment", model = "multivariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov2_pairs <- emmeans(aov2, specs = "treatment", model = "univariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lm1_pairs <- emmeans(lm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)


table_dt <- rbind(lmm1_pairs,
                  lmm2_pairs,
                  aov1_pairs,
                  aov2_pairs,
                  lm1_pairs,
                  ttest1_pairs)

table_dt %>%
  kable(digits = c(1, 3, 3, 3, 3, 3, 3, 4), caption = "models") %>%
  kable_styling() %>%
  pack_rows("lmm1 - random intercept", 1, 3) %>%
  pack_rows("lmm2 - heterogenous variance", 4, 6) %>%
  pack_rows("aov1 - multivariate RM ANOVA", 7, 9) %>%
  pack_rows("aov2 - univariate RM ANOVA", 10, 12) %>%
  pack_rows("lm1 - additive lm", 13, 15) %>%
  pack_rows("ttest1 - paired t", 16, 18)

```

### check understanding (what are the coefficients?)

```{r}
fake_rcbd <- simulator(
  seed_i = 3,
  n_treat = 2, # number of treatment levels
  n_block = 5, # number of litters (blocks)
  n_ss = 1, # number of subsamples
  design = "rcbd",
  beta = c(10, 1, 0.5),
  sigma_exp.block = 1, # sd among exp:block (or block if n_exp = 1)
  sigma_ss = 0.5, # sd among subsamples within replication of treatment:block
  block_name = "litter",
  rep_name = "mouse",
  ss_name = "ss"
)

lmm1 <- lmer(sim_1 ~ treatment + (1 | block), data = fake_rcbd)
b <- coef(summary(lmm1))[, "Estimate"]
b0 <- b[1]
mean(fake_rcbd[treatment == "Cn", sim_1])

b0j <- ranef(lmm1)$block[, 1]

data.table(
  treatment = fake_rcbd[treatment == "Cn", treatment],
  treatment = fake_rcbd[treatment == "Cn", block],
  y = fake_rcbd[treatment == "Cn", sim_1],
  b0 = b[1],
  b0j = b0j,
  y_recon = b[1] +  b0j
  )

# hmm so random intercept is not a function of ref only

m1 <- lm(sim_1 ~ treatment, data = fake_rcbd)
fake_rcbd[, y_res := residuals(m1)]
fake_rcbd[, .(y_res = mean(y_res)), by = block]

res_y <- fake_rcbd[, .(y_res = mean(y_res)), by = block]$y_res
res_cn <- fake_rcbd[treatment == "Cn", .(y_res = mean(y_res)), by = block]$y_res
res_tr1 <- fake_rcbd[treatment == "Tr1", .(y_res = mean(y_res)), by = block]$y_res
res_tr2 <- fake_rcbd[treatment == "Tr2", .(y_res = mean(y_res)), by = block]$y_res

data.table(
  block = 1:5,
  b0j = b0j,
  res_y = res_y,
  res_cn = res_cn,
  res_tr1 = res_tr1,
  res_tr2 = res_tr2
)

# the estimated random intercepts are "shrunken" effects - duh!!!!


```


### unbalanced

mouse_04 from litter_02 is missing. The ANOVA models delete all litter_02 data (mouse_05 and mouse_06) -- as a consequence the df is lower and power is lower.

```{r fake_rcbd-unbalanced}
ex_list <- c("mouse_04")
in_list <- setdiff(unique(fake_rcbd$mouse), ex_list)
fake_rcbd_missing <- fake_rcbd[mouse %in% in_list]

# models
lmm1 <- lmer(sim_1 ~ treatment + (1 | block),
              data = fake_rcbd_missing)
# lmm2a <- lme(sim_1 ~ treatment,
#             random = ~1 | block,
#             correlation = corSymm(form = ~ 1 | block),
#             weights = varIdent(form = ~ 1 | treatment),
#             data = fake_rcbd_missing)

aov1 <- aov_4(sim_1 ~ treatment + (treatment | block),
              data = fake_rcbd_missing)
aov2 <- aov_4(sim_1 ~ treatment + (treatment | block),
           include_aov = TRUE,
              data = fake_rcbd_missing)

lm1 <- lm(sim_1 ~ treatment + block,
              data = fake_rcbd_missing)

ttest1_pairs <- pairwise_t_tests(y_col = "sim_1",
                           g_col = "treatment",
                           id_col = "litter",
                           data = fake_rcbd_missing)

# contrasts
lmm1_pairs <- emmeans(lmm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov1_pairs <- emmeans(aov1, specs = "treatment", model = "multivariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov2_pairs <- emmeans(aov2, specs = "treatment", model = "univariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lm1_pairs <- emmeans(lm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)


table_dt <- rbind(lmm1_pairs,
                  aov1_pairs,
                  aov2_pairs,
                  lm1_pairs,
                  ttest1_pairs)

table_dt %>%
  kable(digits = c(1, 3, 3, 3, 3, 3, 3, 4), caption = "models") %>%
  kable_styling() %>%
  pack_rows("lmm1 - random intercept", 1, 3) %>%
  pack_rows("aov1 - multivariate RM ANOVA", 4, 6) %>%
  pack_rows("aov2 - univariate RM ANOVA", 7, 9) %>%
  pack_rows("lm1 - additive lm", 10, 12) %>%
  pack_rows("ttest1 - paired t-tests", 13, 15)
```

### Litter_02 deletion

```{r fake_rcbd-litter2-deletion}
ex_list <- c("mouse_04")
in_list <- setdiff(unique(fake_rcbd$mouse), ex_list)
fake_rcbd_missing <- fake_rcbd[mouse %in% in_list]

fake_rcbd_missing <- fake_rcbd[litter != "litter_02"]

# models
lmm1 <- lmer(sim_1 ~ treatment + (1 | block),
              data = fake_rcbd_missing)
# lmm2a <- lme(sim_1 ~ treatment,
#             random = ~1 | block,
#             correlation = corSymm(form = ~ 1 | block),
#             weights = varIdent(form = ~ 1 | treatment),
#             data = fake_rcbd_missing)
# lmm2b <- lme(sim_1 ~ treatment,
#              random = ~1 | block,
#              correlation = corCompSymm(form = ~ 1 | block),
#              weights = varIdent(form = ~ 1 | treatment),
#              control = lmeControl(opt='optim'),
#              #            control = lmeControl(maxIter = 1e3),
#              data = fake_rcbd_missing)

aov1 <- aov_4(sim_1 ~ treatment + (treatment | block),
              data = fake_rcbd_missing)
aov2 <- aov_4(sim_1 ~ treatment + (treatment | block),
           include_aov = TRUE,
              data = fake_rcbd_missing)

lm1 <- lm(sim_1 ~ treatment + block,
              data = fake_rcbd_missing)

# contrasts
lmm1_pairs <- emmeans(lmm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov1_pairs <- emmeans(aov1, specs = "treatment", model = "multivariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov2_pairs <- emmeans(aov2, specs = "treatment", model = "univariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lm1_pairs <- emmeans(lm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)


table_dt <- rbind(lmm1_pairs,
                  aov1_pairs,
                  aov2_pairs,
                  lm1_pairs)

table_dt %>%
  kable(digits = c(1, 3, 3, 3, 3, 3, 3, 4), caption = "models") %>%
  kable_styling() %>%
  pack_rows("lmm1 - random intercept", 1, 3) %>%
  pack_rows("aov1 - multivariate RM ANOVA", 4, 6) %>%
  pack_rows("aov2 - univariate RM ANOVA", 7, 9) %>%
  pack_rows("lm1 - additive lm", 10, 12)
```

## GRCBD

```{r fake_grcbd}
seed_starter <- 5
fake_grcbd <- simulator(
  seed_i = seed_starter,
  n_treat = 3, # number of treatment levels
  n_block = 6, # number of litters (blocks)
  n_rep = 3, # number of mice per experiment:treatment
  n_ss = 1, # number of subsamples
  design = "rcbd",
  beta = c(10, 3, 2),
  sigma_exp.block = 1, # sd among exp:block (or block if n_exp = 1)
  sigma_exp.block.treat = c(2, 1, 0.2),
  sigma_rep = 0.1,
  sigma_ss = 0.5, # sd among subsamples within replication of treatment:block
  block_name = "experiment",
  rep_name = "mouse",
  ss_name = "ss"

)

```

### check understanding (what are the coefficients?)

```{r}
lmm0 <- lmer(sim_1 ~ treatment + (1 | block), data = fake_grcbd)
lmm1 <- lmer(sim_1 ~ treatment + (treatment | block), data = fake_grcbd)
b <- coef(summary(lmm1))[, "Estimate"]
b0 <- b[1]
b0
mean(fake_grcbd[treatment == "Cn", sim_1])

b0j <- ranef(lmm1)

data.table(
  treatment = fake_grcbd[treatment == "Cn", treatment],
  treatment = fake_grcbd[treatment == "Cn", block],
  y = fake_grcbd[treatment == "Cn", sim_1],
  b0 = b[1],
  b0j = rep(b0j$block[, 1], each = 3),
  y_recon = b[1] +  rep(b0j$block[, 1], each = 3)
  )

# hmm so random intercept is not a function of ref only

m1 <- lm(sim_1 ~ treatment, data = fake_grcbd)
fake_grcbd[, y_res := residuals(m1)]
fake_grcbd[treatment == "Cn", .(y = mean(sim_1)), by = block]

fake_grcbd[, .(y_res = mean(y_res)), by = block]

ranef(lmm0)
ranef(lmm1)
# the estimated random intercepts are "shrunken" effects - duh!!!!

res_y <- fake_grcbd[, .(y_res = mean(y_res)), by = block]$y_res
res_cn <- fake_grcbd[treatment == "Cn", .(y_res = mean(y_res)), by = block]$y_res
res_tr1 <- fake_grcbd[treatment == "Tr1", .(y_res = mean(y_res)), by = block]$y_res
res_tr2 <- fake_grcbd[treatment == "Tr2", .(y_res = mean(y_res)), by = block]$y_res

data.table(
  block = 1:5,
  b0j = b0j$block[, 1],
  res_y = res_y,
  res_cn = res_cn,
  res_tr1 = res_tr1,
  res_tr2 = res_tr2
)

type3 <- list(treatment = contr.sum,
              block = contr.sum)

lm1 <- lm(sim_1 ~ treatment * block, data = fake_grcbd, contrasts = type3)
coef(summary(lm1))
```

### balanced

```{r fake_grcbd-balanced}
# models
lmm3 <-  lmer(sim_1 ~ treatment + (treatment | experiment),
               data = fake_grcbd)

lmm4 <-  lmer(sim_1 ~ treatment + (1 | experiment) + (1 | experiment:treatment),
               data = fake_grcbd)

fake_grcbd_means <- fake_grcbd[, .(sim_1 = mean(sim_1)), by = .(experiment, treatment)]
lmm1 <-  lmer(sim_1 ~ treatment + (1 | experiment),
               data = fake_grcbd_means)
lmm2 <- lme(sim_1 ~ treatment,
             random = ~1 | experiment,
             correlation = corSymm(form = ~ 1 | experiment),
             weights = varIdent(form = ~ 1 | treatment),
             data = fake_grcbd_means)

aov1 <- aov_4(sim_1 ~ treatment + (treatment | experiment),
              fun_aggregate = mean,
              data = fake_grcbd)
aov2 <- aov_4(sim_1 ~ treatment + (treatment | experiment),
              fun_aggregate = mean,
              include_aov = TRUE,
              data = fake_grcbd)

lm1 <- lm(sim_1 ~ treatment * experiment,
               data = fake_grcbd)

ttest1_pairs <- pairwise_t_tests(y_col = "sim_1",
                           g_col = "treatment",
                           id_col = "experiment",
                           data = fake_grcbd)

# contrasts

lmm3_pairs <- emmeans(lmm3, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm4_pairs <- emmeans(lmm4, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm1_pairs <- emmeans(lmm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm2_pairs <- emmeans(lmm2, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov1_pairs <- emmeans(aov1, specs = "treatment", model = "multivariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov2_pairs <- emmeans(aov2, specs = "treatment", model = "univariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lm1_pairs <- emmeans(lm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)


table_dt <- rbind(lmm3_pairs,
                  lmm4_pairs,
                  lmm1_pairs,
                  lmm2_pairs,
                  aov1_pairs,
                  aov2_pairs,
                  lm1_pairs,
                  ttest1_pairs)

table_dt %>%
  kable(digits = c(1, 3, 3, 3, 3, 3, 3, 4), caption = "models") %>%
  kable_styling() %>%
  pack_rows("lmm3 - random slope & intercept", 1, 3) %>%
  pack_rows("lmm4 - random interaction intercept", 4, 6) %>%
  pack_rows("lmm1 - aggregated random intercept", 7, 9) %>%
  pack_rows("lmm2 - aggregated heterogenous variance", 10, 12) %>%
  pack_rows("aov1 - multivariate RM ANOVA", 13, 15) %>%
  pack_rows("aov12 - univariate RM ANOVA", 16, 18) %>%
  pack_rows("lm1 - fixed effects model", 19, 21) %>%
  pack_rows("ttest1 - paired t-tests", 22, 24)
```

```{r grcbd-varcorr, eval=FALSE, echo=FALSE}
VarCorr(lmm3)
VarCorr(lmm4)
```

### unbalanced

If there is a missing treatment level in one experiment (this is common in the lit), then AOV throws out the whole experiment, ignoring data from the other treatment levels.

If only a single mouse from a treatment is missing, the whole experiment is not thrown out because other measures in that treatment:experiment combo are present.

```{r fake_grcbd-unbalanced}
ex_list <- c("mouse_04")
in_list <- setdiff(unique(fake_grcbd$mouse), ex_list)
fake_grcbd_missing <- fake_grcbd[mouse %in% in_list]

# missing Cn from experiment_01
ex_list <- c("mouse_01", "mouse_02", "mouse_03")
in_list <- setdiff(unique(fake_grcbd$mouse), ex_list)
fake_grcbd_missing <- fake_grcbd[mouse %in% in_list]

lmm3 <-  lmer(sim_1 ~ treatment + (treatment | experiment),
               data = fake_grcbd_missing)

lmm4 <-  lmer(sim_1 ~ treatment + (1 | experiment) + (1 | experiment:treatment),
               data = fake_grcbd_missing)

fake_grcbd_means <- fake_grcbd_missing[, .(sim_1 = mean(sim_1)), by = .(experiment, treatment)]
lmm1 <-  lmer(sim_1 ~ treatment + (1 | experiment),
               data = fake_grcbd_means)
lmm2 <- lme(sim_1 ~ treatment,
             random = ~1 | experiment,
             correlation = corSymm(form = ~ 1 | experiment),
             weights = varIdent(form = ~ 1 | treatment),
             data = fake_grcbd_means,
            control = lmeControl(returnObject = TRUE))

aov1 <- aov_4(sim_1 ~ treatment + (treatment | experiment),
              fun_aggregate = mean,
              data = fake_grcbd_missing)
aov2 <- aov_4(sim_1 ~ treatment + (treatment | experiment),
              fun_aggregate = mean,
              include_aov = TRUE,
              data = fake_grcbd_missing)

lm1 <- lm(sim_1 ~ treatment + experiment,
               data = fake_grcbd_means)

ttest1_pairs <- pairwise_t_tests(y_col = "sim_1",
                           g_col = "treatment",
                           id_col = "experiment",
                           data = fake_grcbd_missing)

# contrasts

lmm3_pairs <- emmeans(lmm3, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm4_pairs <- emmeans(lmm4, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm1_pairs <- emmeans(lmm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm2_pairs <- emmeans(lmm2, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov1_pairs <- emmeans(aov1, specs = "treatment", model = "multivariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov2_pairs <- emmeans(aov2, specs = "treatment", model = "univariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lm1_pairs <- emmeans(lm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)

table_dt <- rbind(lmm3_pairs,
                  lmm4_pairs,
                  lmm1_pairs,
                  lmm2_pairs,
                  aov1_pairs,
                  aov2_pairs,
                  lm1_pairs,
                  ttest1_pairs)

table_dt %>%
  kable(digits = c(1, 3, 3, 3, 3, 3, 3, 4), caption = "models") %>%
  kable_styling() %>%
  pack_rows("lmm3 - random slope & intercept", 1, 3) %>%
  pack_rows("lmm4 - random interaction intercept", 4, 6) %>%
  pack_rows("lmm1 - aggregated random intercept", 7, 9) %>%
  pack_rows("lmm2 - aggregated heterogenous variance", 10, 12) %>%
  pack_rows("aov1 - multivariate RM ANOVA", 13, 15) %>%
  pack_rows("aov2 - univariate RM ANOVA", 16, 18) %>%
  pack_rows("lm1 - fixed effect model", 19, 21) %>%
  pack_rows("ttest1 - paired t-tests", 22, 24)
```

### Delete all experiment_01

```{r fake_grcbd-unbalanced-2}
fake_grcbd_missing <- fake_grcbd[experiment != "experiment_01"]

lmm4 <-  lmer(sim_1 ~ treatment + (1 | experiment) + (1 | experiment:treatment),
               data = fake_grcbd_missing)

fake_grcbd_means <- fake_grcbd_missing[, .(sim_1 = mean(sim_1)), by = .(experiment, treatment)]
lmm1 <-  lmer(sim_1 ~ treatment + (1 | experiment),
               data = fake_grcbd_means)
aov2 <- aov_4(sim_1 ~ treatment + (treatment | experiment),
           include_aov = TRUE,
              data = fake_grcbd_missing)

# contrasts

lmm4_pairs <- emmeans(lmm4, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm1_pairs <- emmeans(lmm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov2_pairs <- emmeans(aov2, specs = "treatment", model = "univariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)


table_dt <- rbind(lmm4_pairs,
                  lmm1_pairs,
                  aov2_pairs)

table_dt %>%
  kable(digits = c(1, 3, 3, 3, 3, 3, 3, 4), caption = "models") %>%
  kable_styling() %>%
  pack_rows("lmm3 - random interaction intercept", 1, 3) %>%
  pack_rows("lmm4 - aggregated random intercept", 4, 6) %>%
  pack_rows("aov2 - univariate RM ANOVA", 7, 9)
```

## RCBDS

```{r fake_rcbds}
seed_starter <- 1
seed_starter <- seed_starter + 1
fake_rcbds <- simulator(
  seed_i = seed_starter,
  n_sim = 1,
  n_treat = 3, # number of treatment levels
  n_block = 6, # number of litters (blocks)
  n_rep = 1, # number of mice per litter:treatment
  n_ss = 5, # number of subsamples
  design = "rcbd",
  correlated_slopes = TRUE, # TRUE uses random int/slope model to generate data
  beta = c(10, 1, -1),
  block_name = "litter",
  rep_name = "mouse",
  ss_name = "ss"
)

```

### balanced

```{r fake_rcbds-balanced}
lmm3 <-  lmer(sim_1 ~ treatment + (treatment | litter),
               data = fake_rcbds)
lmm4 <-  lmer(sim_1 ~ treatment + (1 | litter) + (1 | litter:treatment),
               data = fake_rcbds)

fake_rcbds_means <- fake_rcbds[, .(sim_1 = mean(sim_1)),
                               by = .(litter, treatment, mouse)]
fake_rcbds_means <- fake_rcbds_means[, .(sim_1 = mean(sim_1)),
                               by = .(litter, treatment)]

lmm1 <-  lmer(sim_1 ~ treatment + (1 | litter),
               data = fake_rcbds_means)
lmm2 <- lme(sim_1 ~ treatment,
             random = ~1 | litter,
             correlation = corSymm(form = ~ 1 | litter),
             weights = varIdent(form = ~ 1 | treatment),
             data = fake_rcbds_means)

aov1 <- aov_4(sim_1 ~ treatment + (treatment | litter),
               data = fake_rcbds)
aov2 <- aov_4(sim_1 ~ treatment + (treatment | litter),
           include_aov = TRUE,
              data = fake_rcbds)

# contrasts

lmm3_pairs <- emmeans(lmm3, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm4_pairs <- emmeans(lmm4, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm1_pairs <- emmeans(lmm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm2_pairs <- emmeans(lmm2, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov1_pairs <- emmeans(aov1, specs = "treatment", model = "multivariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov2_pairs <- emmeans(aov2, specs = "treatment", model = "univariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)

table_dt <- rbind(lmm3_pairs,
                  lmm4_pairs,
                  lmm1_pairs,
                  lmm2_pairs,
                  aov1_pairs,
                  aov2_pairs)

table_dt %>%
  kable(digits = c(1, 3, 3, 3, 3, 3, 3, 4), caption = "models") %>%
  kable_styling() %>%
  pack_rows("lmm3 - random slope & intercept", 1, 3) %>%
  pack_rows("lmm4 - random interaction intercept 1", 4, 6) %>%
  pack_rows("lmm1 - aggregated random intercept", 7, 9) %>%
  pack_rows("lmm2 - aggregated heterogenous variance", 10, 12) %>%
  pack_rows("aov1 - multivariate RM ANOVA", 13, 15) %>%
  pack_rows("aov2 - univariate RM ANOVA", 16, 18)
```

### unbalanced 1

```{r fake_rcbds-unbalanced}
ex_list <- c("mouse_04")
in_list <- setdiff(unique(fake_rcbds$mouse), ex_list)
fake_rcbds_missing <- fake_rcbds[mouse %in% in_list]

lmm3 <-  lmer(sim_1 ~ treatment + (treatment | litter),
               data = fake_rcbds_missing)

lmm4 <-  lmer(sim_1 ~ treatment + (1 | litter) + (1 | litter:treatment),
               data = fake_rcbds_missing)

fake_rcbds_means <- fake_rcbds_missing[, .(sim_1 = mean(sim_1)),
                               by = .(litter, treatment, mouse)]
fake_rcbds_means <- fake_rcbds_means[, .(sim_1 = mean(sim_1)),
                               by = .(litter, treatment)]

lmm1 <-  lmer(sim_1 ~ treatment + (1 | litter),
               data = fake_rcbds_means)
lmm2 <- lme(sim_1 ~ treatment,
            random = ~1 | litter,
            correlation = corSymm(form = ~ 1 | litter),
            weights = varIdent(form = ~ 1 | treatment),
            data = fake_rcbds_means,
            control = lmeControl(returnObject = TRUE))

aov1 <- aov_4(sim_1 ~ treatment + (treatment | litter),
               data = fake_rcbds_missing)
aov2 <- aov_4(sim_1 ~ treatment + (treatment | litter),
           include_aov = TRUE,
              data = fake_rcbds_missing)

# contrasts

lmm3_pairs <- emmeans(lmm3, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm4_pairs <- emmeans(lmm4, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm1_pairs <- emmeans(lmm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm2_pairs <- emmeans(lmm2, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov1_pairs <- emmeans(aov1, specs = "treatment", model = "multivariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov2_pairs <- emmeans(aov2, specs = "treatment", model = "univariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)

table_dt <- rbind(lmm3_pairs,
                  lmm4_pairs,
                  lmm1_pairs,
                  lmm2_pairs,
                  aov1_pairs,
                  aov2_pairs)

table_dt %>%
  kable(digits = c(1, 3, 3, 3, 3, 3, 3, 4), caption = "models") %>%
  kable_styling() %>%
  pack_rows("lmm3 - random slope & intercept", 1, 3) %>%
  pack_rows("lmm4 - random interaction intercept 1", 4, 6) %>%
  pack_rows("lmm1 - aggregated random intercept", 7, 9) %>%
  pack_rows("lmm2 - aggregated heterogenous variance", 10, 12) %>%
  pack_rows("aov1 - multivariate RM ANOVA", 13, 15) %>%
  pack_rows("aov2 - univariate RM ANOVA", 16, 18)
```

### delete litter_02

```{r fake_rcbds-deletion}
ex_list <- c("mouse_04")
in_list <- setdiff(unique(fake_rcbds$mouse), ex_list)
fake_rcbds_missing <- fake_rcbds[mouse %in% in_list]
fake_rcbds_missing <- fake_rcbds[litter != "litter_02"]

lmm3 <-  lmer(sim_1 ~ treatment + (treatment | litter),
               data = fake_rcbds_missing)

lmm4 <-  lmer(sim_1 ~ treatment + (1 | litter) + (1 | litter:treatment),
               data = fake_rcbds_missing)

fake_rcbds_means <- fake_rcbds_missing[, .(sim_1 = mean(sim_1)),
                               by = .(litter, treatment, mouse)]
fake_rcbds_means <- fake_rcbds_means[, .(sim_1 = mean(sim_1)),
                               by = .(litter, treatment)]

lmm1 <-  lmer(sim_1 ~ treatment + (1 | litter),
               data = fake_rcbds_means)
lmm2 <- lme(sim_1 ~ treatment,
             random = ~1 | litter,
             correlation = corSymm(form = ~ 1 | litter),
             weights = varIdent(form = ~ 1 | treatment),
             data = fake_rcbds_means)

aov1 <- aov_4(sim_1 ~ treatment + (treatment | litter),
               data = fake_rcbds_missing)
aov2 <- aov_4(sim_1 ~ treatment + (treatment | litter),
           include_aov = TRUE,
              data = fake_rcbds_missing)

# contrasts

lmm3_pairs <- emmeans(lmm3, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm4_pairs <- emmeans(lmm4, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm1_pairs <- emmeans(lmm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm2_pairs <- emmeans(lmm2, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov1_pairs <- emmeans(aov1, specs = "treatment", model = "multivariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov2_pairs <- emmeans(aov2, specs = "treatment", model = "univariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)

table_dt <- rbind(lmm3_pairs,
                  lmm4_pairs,
                  lmm1_pairs,
                  lmm2_pairs,
                  aov1_pairs,
                  aov2_pairs)

table_dt %>%
  kable(digits = c(1, 3, 3, 3, 3, 3, 3, 4), caption = "models") %>%
  kable_styling() %>%
  pack_rows("lmm3 - random slope & intercept", 1, 3) %>%
  pack_rows("lmm4 - random interaction intercept 1", 4, 6) %>%
  pack_rows("lmm1 - aggregated random intercept", 7, 9) %>%
  pack_rows("lmm2 - aggregated heterogenous variance", 10, 12) %>%
  pack_rows("aov1 - multivariate RM ANOVA", 13, 15) %>%
  pack_rows("aov2 - univariate RM ANOVA", 16, 18)
```
### unbalanced 2

```{r fake_rcbds-unbalanced-2}
N <- nrow(fake_rcbds)
inc <- sample(1:N, (N-10))
fake_rcbds_missing <- fake_rcbds[inc]
fake_rcbds_means <- fake_rcbds_missing[, .(sim_1 = mean(sim_1)),
                               by = .(litter, treatment, mouse)]
fake_rcbds_means[, .(N = .N),
                   by = .(treatment, litter)]

lmm3 <-  lmer(sim_1 ~ treatment + (treatment | litter),
               data = fake_rcbds_missing)

lmm4 <-  lmer(sim_1 ~ treatment + (1 | litter) + (1 | litter:treatment),
               data = fake_rcbds_missing)

fake_rcbds_means <- fake_rcbds_missing[, .(sim_1 = mean(sim_1)),
                               by = .(litter, treatment, mouse)]
fake_rcbds_means <- fake_rcbds_means[, .(sim_1 = mean(sim_1)),
                               by = .(litter, treatment)]

lmm1 <-  lmer(sim_1 ~ treatment + (1 | litter),
               data = fake_rcbds_means)
lmm2 <- lme(sim_1 ~ treatment,
             random = ~1 | litter,
             correlation = corSymm(form = ~ 1 | litter),
             weights = varIdent(form = ~ 1 | treatment),
             data = fake_rcbds_means,
            control = lmeControl(returnObject = TRUE))

aov1 <- aov_4(sim_1 ~ treatment + (treatment | litter),
               data = fake_rcbds_missing)
aov2 <- aov_4(sim_1 ~ treatment + (treatment | litter),
           include_aov = TRUE,
              data = fake_rcbds_missing)

# contrasts

lmm3_pairs <- emmeans(lmm3, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm4_pairs <- emmeans(lmm4, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm1_pairs <- emmeans(lmm1, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
lmm2_pairs <- emmeans(lmm2, specs = "treatment") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov1_pairs <- emmeans(aov1, specs = "treatment", model = "multivariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)
aov2_pairs <- emmeans(aov2, specs = "treatment", model = "univariate") %>%
  contrast(method = "revpairwise", adjust = "none") %>%
  summary(infer = TRUE)

table_dt <- rbind(lmm3_pairs,
                  lmm4_pairs,
                  lmm1_pairs,
                  lmm2_pairs,
                  aov1_pairs,
                  aov2_pairs)

table_dt %>%
  kable(digits = c(1, 3, 3, 3, 3, 3, 3, 4), caption = "models") %>%
  kable_styling() %>%
  pack_rows("lmm3 - random slope & intercept", 1, 3) %>%
  pack_rows("lmm4 - random interaction intercept 1", 4, 6) %>%
  pack_rows("lmm1 - aggregated random intercept", 7, 9) %>%
  pack_rows("lmm2 - aggregated heterogenous variance", 10, 12) %>%
  pack_rows("aov1 - multivariate RM ANOVA", 13, 15) %>%
  pack_rows("aov2 - univariate RM ANOVA", 16, 18)
```

# Assumptions of linear mixed models

The models make different assumptions about the correlated error and these, in turn, make models fit to the data more or less conservative (More conservative is fewer false positives at the expense of power. Less conservative is more false positives but a gain in power). What are these assumptions?

Assumption list:

1. variances of the Cn, Tr1, and Tr2 residuals are the same (covariance matrix below)
2. the 3 correlations among the Cn, Tr1, and Tr2 residual are the same (figure 1 below and correlation matrix)
3. there is no block:treatment interaction, that is, no random slopes (figure 2 below)
4. there is no correlation between random intercepts and random slopes

Model assumptions

1. lmm1 -- assumes 1-4
2. lmm2 -- is highly flexible. As coded, it makes no assumptions (or maybe 4?)
3. lmm3 -- assumes 1, 2, 4
4. lmm4 -- none
5. aov1 -- none
6. aov2 -- assumes 1, 2, 4


## Correlated error

This is a RCBD simulation with 50 litters. Three sibs within each litter are randomly assigned to treatment (t = 3 treatment levels). The data in the plots are the residuals of the linear model y ~ treatment. These residuals are correlated. If the cn mouse from litter 14 has a high residual, the tr1 and tr2 residuals are probably also high. If the cn mouse from litter 27 has a low residual, the tr1 and tr2 residuals are probably also low.

```{r correlation-assumpation, caption = "Scatterplot of residuals of linear model y ~ treatment showing correlated error. The data simulate an RCBD with 50 litters and three mice per litter assigned to the three treatment levels."}
seed_starter <- seed_starter + 1
fake_rcbd <- simulator(
  seed_i = seed_starter,
  n_sim = 1,
  n_treat = 3, # number of treatment levels
  n_block = 50, # number of litters (blocks)
  n_rep = 1, # number of mice per litter:treatment
  n_ss = 1, # number of subsamples
  design = "rcbd",
  correlated_slopes = FALSE, # TRUE uses random int/slope model to generate data
  beta = c(10, 0, 0),
  gamma = c(0.5, 0.5, 0.5), # sd of random intercept and slopes for non-ref
  rho = 0.0, # r between random intercept and slopes
  sigma_exp = 0, # sd among experiments
  sigma_exp.block = 1, # sd among exp:block (or block if n_exp = 1)
  sigma_exp.treat = 0, # sd among exp:treat
  sigma_exp.block.treat = 0, # sd among exp:block:treat
  sigma_rep = 0,
  sigma_ss = 0.6, # sd among subsamples within replication of treatment:block
  block_name = "litter",
  rep_name = "mouse",
  ss_name = "ss"
)

m1 <- lm(sim_1 ~ treatment, data = fake_rcbd)
fake_rcbd[, y_res := residuals(m1)]
fake_rcbd_wide <- dcast(fake_rcbd,
                        litter ~ treatment,
                        value.var = "y_res")
gg1 <- ggplot(data = fake_rcbd_wide,
              aes(x = Cn, y = Tr1)) +
  geom_point()
gg2 <- ggplot(data = fake_rcbd_wide,
              aes(x = Cn, y = Tr2)) +
  geom_point()
gg3 <- ggplot(data = fake_rcbd_wide,
              aes(x = Tr1, y = Tr2)) +
  geom_point()
plot_grid(gg1, gg2, gg3, nrow = 2)

# covij <- 1^2
# sdi <- sqrt(1^2 + 0.6^2)
# covij/sdi^2
# 
# y_cols <- c("Cn", "Tr1", "Tr2")
# cov(fake_rcbd_wide[, .SD, .SDcols = y_cols]) %>%
#   kable(digits = 3,
#         caption = "Covariance matrix of residuals") %>%
#   kable_styling(full_width = FALSE)
# cor(fake_rcbd_wide[, .SD, .SDcols = y_cols]) %>%
#   kable(digits = 3,
#         caption = "Correlation matrix of residuals") %>%
#   kable_styling(full_width = FALSE)

```


This is the same simulation but with 1000 blocks so that the covariance/correlation estimates have low error. Two sets of covariance and correlation matrices are shown.

In the first set, the variances of the residuals are about 1.4 for each treatment (these are on the diagonal of the covariance matrix) and the correlations are about 0.74 for each pair (these are the off-diagonal of the correlation matrix).

In the second set, the variances of the residuals differ for each treatment (these are on the diagonal of the covariance matrix) and the correlations differ for each pair (these are the off-diagonal of the correlation matrix).

```{r covariance-assumpation-1}
seed_starter <- 1
fake_rcbd <- simulator(
  seed_i = seed_starter + 1,
  n_sim = 1,
  n_treat = 3, # number of treatment levels
  n_block = 1000, # number of litters (blocks)
  n_rep = 1, # number of mice per litter:treatment
  n_ss = 1, # number of subsamples
  design = "rcbd",
  correlated_slopes = FALSE, # TRUE uses random int/slope model to generate data
  beta = c(10, 0, 0),
  gamma = c(0.5, 0.5, 0.5), # sd of random intercept and slopes for non-ref
  rho = 0.0, # r between random intercept and slopes
  sigma_exp = 0, # sd among experiments
  sigma_exp.block = 1, # sd among exp:block (or block if n_exp = 1)
  sigma_exp.treat = 0, # sd among exp:treat
  sigma_exp.block.treat = 0, # sd among exp:block:treat
  sigma_rep = 0,
  sigma_ss = 0.6, # sd among subsamples within replication of treatment:block
  block_name = "litter",
  rep_name = "mouse",
  ss_name = "ss"
)

m1 <- lm(sim_1 ~ treatment, data = fake_rcbd)
fake_rcbd[, y_res := residuals(m1)]
fake_rcbd_wide <- dcast(fake_rcbd,
                        litter ~ treatment,
                        value.var = "y_res")

# covij <- 1^2
# sdi <- sqrt(1^2 + 0.6^2)
# covij/sdi^2
# 
y_cols <- c("Cn", "Tr1", "Tr2")
cov(fake_rcbd_wide[, .SD, .SDcols = y_cols]) %>%
  kable(digits = 3,
        caption = "Covariance matrix of residuals, simulation 1") %>%
  kable_styling(full_width = FALSE)
cor(fake_rcbd_wide[, .SD, .SDcols = y_cols]) %>%
  kable(digits = 3,
        caption = "Correlation matrix of residuals, simulation 1") %>%
  kable_styling(full_width = FALSE)

fake_rcbd <- simulator(
  seed_i = seed_starter + 1,
  n_sim = 1,
  n_treat = 3, # number of treatment levels
  n_block = 1000, # number of litters (blocks)
  n_rep = 1, # number of mice per litter:treatment
  n_ss = 1, # number of subsamples
  design = "rcbd",
  correlated_slopes = FALSE, # TRUE uses random int/slope model to generate data
  beta = c(10, 0, 0),
  sigma_exp = 0, # sd among experiments
  sigma_exp.block = 1, # sd among exp:block (or block if n_exp = 1)
  sigma_exp.treat = 0, # sd among exp:treat
  sigma_exp.block.treat = c(1, 0, 0.5), # sd among exp:block:treat
  sigma_rep = 0,
  sigma_ss = 0.6, # sd among subsamples within replication of treatment:block
  block_name = "litter",
  rep_name = "mouse",
  ss_name = "ss"
)

m1 <- lm(sim_1 ~ treatment, data = fake_rcbd)
fake_rcbd[, y_res := residuals(m1)]
fake_rcbd_wide <- dcast(fake_rcbd,
                        litter ~ treatment,
                        value.var = "y_res")

# covij <- 1^2
# sdi <- sqrt(1^2 + 0.6^2)
# covij/sdi^2
# 
y_cols <- c("Cn", "Tr1", "Tr2")
cov(fake_rcbd_wide[, .SD, .SDcols = y_cols]) %>%
  kable(digits = 3,
        caption = "Covariance matrix of residuals, simulation 2") %>%
  kable_styling(full_width = FALSE)
cor(fake_rcbd_wide[, .SD, .SDcols = y_cols]) %>%
  kable(digits = 3,
        caption = "Correlation matrix of residuals, simulation 2") %>%
  kable_styling(full_width = FALSE)

```



## block:treatment interaction (random slopes)

This is a GRCBD simulation with 3 experiments. Each experiment is a typical CRD with three treatment levels and 10 mice assigned to each. Experiment is the block. There is experimental replication of treatment level within each block so the design is GRCBD.

In the first simulation, there is no block:treatment interaction. The experiment_03 mice have relatively high glucose in all three treatments. Note that the slopes within an experiment are all close to zero.

In the second simulation, there is a block:treatment interaction. The experiment_03 mice have kinda high glucose in experiment_01, really high glucose in experiment_02, and intermediate glucose in experiment_03. Note that the slopes within an experiment differ both among experiments within a pair of treatments and among pairs of treatments within an experiment. That is, "random slopes" arise from a block:treatment interaction.

```{r}
seed_starter <- 1
seed_starter <- seed_starter + 1
fake_grcbd <- simulator(
  seed_i = seed_starter,
  n_sim = 1,
  n_treat = 3, # number of treatment levels
  n_block = 3, # number of litters (blocks)
  n_rep = 1, # number of mice per litter:treatment
  n_ss = 1, # number of subsamples
  design = "rcbd",
  correlated_slopes = FALSE, # TRUE uses random int/slope model to generate data
  beta = c(10, 0,0),
  gamma = c(1,1, 0), # sd of random intercept and slopes for non-ref
  rho = 0.0, # r between random intercept and slopes
  sigma_exp = 0, # sd among experiments
  sigma_exp.block = 1, # sd among exp:block (or block if n_exp = 1)
  sigma_exp.treat = 0, # sd among exp:treat
  sigma_exp.block.treat = 0, # sd among exp:block:treat
  # sigma_slope = 0 # creates variation in sigma_exp.block among treatments
  sigma_rep = 0,
  sigma_ss = 0.6, # sd among subsamples within replication of treatment:block
  block_name = "experiment",
  rep_name = "mouse",
  ss_name = "ss"
)

m1 <- lm(sim_1 ~ treatment, data = fake_grcbd)
fake_grcbd[, glucose_residual := residuals(m1)]
y_cols <- c("Cn", "Tr1", "Tr2")
fake_grcbd_wide <- dcast(fake_grcbd,
                        experiment + rep ~ treatment,
                        value.var = "glucose_residual")
cov(fake_grcbd_wide[, .SD, .SDcols = y_cols]) %>%
  kable(digits = 3,
        caption = "Covariance matrix of residuals") %>%
  kable_styling(full_width = FALSE)
cor(fake_grcbd_wide[, .SD, .SDcols = y_cols]) %>%
  kable(digits = 3,
        caption = "Correlation matrix of residuals") %>%
  kable_styling(full_width = FALSE)


pd <- position_dodge(0.3)
gg1 <- ggplot(data = fake_grcbd,
              aes(x = treatment,
                  y = glucose_residual,
                  color = experiment)) +
  geom_point(position = pd) +
  theme_pubr() +
  scale_color_manual(values = pal_okabe_ito)


seed_starter <- seed_starter + 1
fake_grcbd <- simulator(
  seed_i = seed_starter,
  n_sim = 1,
  n_treat = 3, # number of treatment levels
  n_block = 3, # number of litters (blocks)
  n_rep = 10, # number of mice per litter:treatment
  n_ss = 1, # number of subsamples
  design = "rcbd",
  correlated_slopes = FALSE, # TRUE uses random int/slope model to generate data
  beta = c(10, 0),
  gamma = c(1,1, 0), # sd of random intercept and slopes for non-ref
  rho = 0.0, # r between random intercept and slopes
  sigma_exp = 0, # sd among experiments
  sigma_exp.block = 1, # sd among exp:block (or block if n_exp = 1)
  sigma_exp.treat = 0, # sd among exp:treat
  sigma_exp.block.treat = 1, # sd among exp:block:treat
  # sigma_slope = 0 # creates variation in sigma_exp.block among treatments
  sigma_rep = 0,
  sigma_ss = 0.6, # sd among subsamples within replication of treatment:block
  block_name = "experiment",
  rep_name = "mouse",
  ss_name = "ss"
)

m1 <- lm(sim_1 ~ treatment, data = fake_grcbd)
fake_grcbd[, glucose_residual := residuals(m1)]

gg2 <- ggplot(data = fake_grcbd,
              aes(x = treatment,
                  y = glucose_residual,
                  color = experiment)) +
  geom_point(position = pd) +
  theme_pubr() +
  scale_color_manual(values = pal_okabe_ito) +
  NULL

plot_grid(gg1, gg2, ncol = 2)
```


## No correlation between random slope and intercept

A correlation between a random intercept and slope means that blocks with higher intercepts have more positive slopes and blocks with lower intercepts have less positive slopse. There will be a correlation between the intercept and each of the slopes and between the each of the slopes. So for an experiment with three treatment levels, there will be a correlation between the random intercept and random slope of Tr1, a correlation between the random intercept and random slope of  Tr2, and correlation between the random slopes of Tr1 and Tr2. 

```{r random-slopes, warning=FALSE, message=FALSE, error=FALSE}
seed_starter <- 5
seed_starter <- seed_starter + 1
fake_rcbd <- simulator(
  seed_i = seed_starter,
  n_sim = 1,
  n_treat = 3, # number of treatment levels
  n_block = 500, # number of litters (blocks)
  n_rep = 10, # number of mice per litter:treatment
  n_ss = 1, # number of subsamples
  design = "rcbd",
  correlated_slopes = TRUE, # TRUE uses random int/slope model to generate data
  beta = c(10, 0),
  gamma = c(1,1, 1), # sd of random intercept and slopes for non-ref
  rho = c(0.0, 0, 0), # r between random intercept and slopes
  sigma_exp = 0, # sd among experiments
  sigma_exp.block = 1, # sd among exp:block (or block if n_exp = 1)
  sigma_exp.treat = 0, # sd among exp:treat
  sigma_exp.block.treat = 1, # sd among exp:block:treat
  # sigma_slope = 0 # creates variation in sigma_exp.block among treatments
  sigma_rep = 0,
  sigma_ss = 0.6, # sd among subsamples within replication of treatment:block
  block_name = "experiment",
  rep_name = "mouse",
  ss_name = "ss"
)


m1 <- lmer(sim_1 ~ treatment + (treatment | experiment), data = fake_rcbd)
coef(m1)$experiment[1:10, ]
cor(coef(m1)$experiment)
VarCorr(m1)

m2 <- lm(sim_1 ~ treatment, data = fake_rcbd)
fake_rcbd[, glucose_residuals := residuals(m2)]
fake_rcbd_wide <- dcast(fake_rcbd,
                        experiment + rep ~ treatment,
                        value.var = "glucose_residuals")


inc <- 1:90
pd <- position_dodge(0.3)
gg1 <- ggplot(data = fake_rcbd[inc],
              aes(x = treatment,
                  y = glucose_residuals,
                  color = experiment)) +
  geom_point(position = pd) +
  theme_pubr()

fake_rcbd <- simulator(
  seed_i = seed_starter,
  n_sim = 1,
  n_treat = 3, # number of treatment levels
  n_block = 500, # number of litters (blocks)
  n_rep = 10, # number of mice per litter:treatment
  n_ss = 1, # number of subsamples
  design = "rcbd",
  correlated_slopes = TRUE, # TRUE uses random int/slope model to generate data
  beta = c(10, 0),
  gamma = c(0.5, 0.5, 0.5), # sd of random intercept and slopes for non-ref
  rho = c(0.9, 0.2, 0.2), # r between random intercept and slopes
  sigma_exp = 0, # sd among experiments
  sigma_exp.block = 1, # sd among exp:block (or block if n_exp = 1)
  sigma_exp.treat = 0, # sd among exp:treat
  sigma_exp.block.treat = 1, # sd among exp:block:treat
  # sigma_slope = 0 # creates variation in sigma_exp.block among treatments
  sigma_rep = 0,
  sigma_ss = 0.3, # sd among subsamples within replication of treatment:block
  block_name = "experiment",
  rep_name = "mouse",
  ss_name = "ss"
)

m1 <- lmer(sim_1 ~ treatment + (treatment | experiment), data = fake_rcbd)
coef(m1)$experiment[1:10, ]
cov(coef(m1)$experiment)
cor(coef(m1)$experiment)
VarCorr(m1)

m2 <- lm(sim_1 ~ treatment, data = fake_rcbd)
fake_rcbd[, glucose_residuals := residuals(m2)]
gg2 <- ggplot(data = fake_rcbd[inc],
              aes(x = treatment,
                  y = glucose_residuals,
                  color = experiment)) +
  geom_point(position = pd) +
  theme_pubr()

plot_grid(gg1, gg2, ncol = 2)
```


# Performance

```{r}
  pless <- function(x){
    value <- sum(x < 0.05, na.rm=TRUE)/length(na.omit(x))
    return(value)
  }

```

## RCBD
**The experimental design**

1. The design is RCBD. There are 10 blocks, each with 3 treatment levels. There is 1 replicate of each treatment in each block. Examples are
    * Three mice are sampled from each of 10 litters. Within each litter, one mouse is assigned to Cn, one to Tr1, and one to Tr2. Litter is the block.
    * Three cultures are randomly assigned to one Cn, one Tr1, and one Tr2. The experiment is replicated 10 times. Experiment is the block.
2. The design is balanced.

**The simulation**

1. Simulation performance is measured as the Type I error rate ("size")
2. Four scenarios are simulated
    * Moderate correlated error. Heterogenous variance and correlation (unstructured error covariance)
    * Small correlated error. Heterogenous variance and correlation (unstructured error covariance)
    * Moderate correlated error. Homogenous variance and correlation (compound symmetry error covariance)
    * No correlated error. Homogenous variance (standard lm assumptions)

**The models**

1. lm0: linear model with treatment as the single factor
3. aov1: multivariate repeated measures ANOVA
4. aov2: univariate repeated measures ANOVA
5. pptt: pairwise, paired t-test
6. lmm2: linear mixed model with heterogeneity.

Notes on models

1. lmm3 (random intercept and slope) is not simulated because the inference is the same as aov1, which is quicker
2. lmm4 (random interaction intercept, aka split plot model) is not simulated because the inference is the same as aov2, which is quicker
3. pptt has same inference as aov1 but including it

```{r rcbd_performance, warning=FALSE, message=FALSE, eval=FALSE}
set.seed(1)
n_sims <- 1000
fake_rcbd <- simulator(
  seed_i = 1,
  n_sim = n_sims,
  n_treat = 3, # number of treatment levels
  n_block = 6, # number of litters (blocks)
  n_rep = 1, # number of mice per litter:treatment
  n_ss = 1, # number of subsamples
  design = "rcbd",
  correlated_slopes = FALSE, # TRUE uses random int/slope model to generate data
  beta = c(10, 0, 0),
  sigma_exp = 0, # sd among experiments
  sigma_exp.block = 1, # sd among exp:block (or block if n_exp = 1)
  sigma_exp.treat = 0, # sd among exp:treat
  sigma_exp.block.treat = c(2, 1, 0.2), # sd among exp:block:treat
  # sigma_slope = 0 # creates variation in sigma_exp.block among treatments
  sigma_rep = 1,
  sigma_ss = 0.1, # sd among subsamples within replication of treatment:block
  block_name = "litter",
  rep_name = "mouse",
  ss_name = "ss"
)


p_mat <- matrix(as.numeric(NA), nrow = n_sims, ncol = 4)
for(i in 1:n_sims){
  
  form_lm <- paste(paste0("sim_", i), "~ treatment") %>%
    formula()
  form_aov <- paste(paste0("sim_", i), "~ treatment + (treatment | litter)") %>%
    formula()
  lm0 <- lm(form_lm, data = fake_rcbd)
  aov2 <- aov_4(form_aov,
                include_aov = TRUE,
                data = fake_rcbd)
  lmm2 <- lme(form_lm,
              random = ~1 | litter,
              correlation = corSymm(form = ~ 1 | litter),
              weights = varIdent(form = ~ 1 | treatment),
              data = fake_rcbd) %>%
    try()
  if(inherits(lmm2, "try-error")){
    lmm2 <- NULL
  }

  lm0_pairs <- emmeans(lm0, specs = "treatment") %>%
    contrast(method = "revpairwise", adjust = "none")
  aov1_pairs <- emmeans(aov2, specs = "treatment", model = "multivariate") %>%
    contrast(method = "revpairwise", adjust = "none")
  aov2_pairs <- emmeans(aov2, specs = "treatment", model = "univariate") %>%
    contrast(method = "revpairwise", adjust = "none")
  if(!is.null(lmm2)){
    lmm2_pairs <- emmeans(lmm2, specs = "treatment") %>%
      contrast(method = "revpairwise", adjust = "none")
      p_mat[i, 4] <- summary(lmm2_pairs)[1, "p.value"]
  }else{
      p_mat[i, 4] <- as.numeric(NA)
  }
    
  p_mat[i, 1] <- summary(lm0_pairs)[1, "p.value"]
  p_mat[i, 2] <- summary(aov1_pairs)[1, "p.value"]
  p_mat[i, 3] <- summary(aov2_pairs)[1, "p.value"]
  
}

colnames(p_mat) <- c("lm0", "aov1", "aov2", "lmm2")
pless <- function(x){
  value <- sum(x < 0.05, na.rm=TRUE)/length(na.omit(x))
  return(value)
}
apply(p_mat, 2, pless)
length(na.omit(p_mat[,4]))
```

```{r rcbd-performance-sim, warning=FALSE, message=FALSE, error=FALSE}
seed_starter <- 1
n_sims <- 1000
do_sim <- FALSE

param_sets <- 3
treatment_levels <- c("Cn", "Tr1", "Tr2")
model_levels <- c("lm0", "lm1", "aov1", "aov2", "pptt", "lmm2")
  
p1_mat <- matrix(as.numeric(NA), nrow = n_sims, ncol = length(model_levels))
p2_mat <- matrix(as.numeric(NA), nrow = n_sims, ncol = length(model_levels))
p3_mat <- matrix(as.numeric(NA), nrow = n_sims, ncol = length(model_levels))
r_mat <- matrix(as.numeric(NA), nrow = n_sims, ncol = 3)

# parameters
beta_i = c(10, 0, 0)

# each row is different param_set
sigma_exp.block.treat_matrix <- matrix(c(
  c(2, 1, 0.2),
  c(0.5, .25, 0.05),
  c(0, 0, 0),
  c(0, 0, 0)
), nrow = 3, ncol = 4) %>%
  t()
colnames(sigma_exp.block.treat_matrix) <- treatment_levels

# each value is different param_set
sigma_exp.block_list <- c(1, 0.25, 0.8, 0)

# each value is different param_set
sigma_ss_list <- c(.1, .4, .4, 1)

param_set_matrix <- data.table(
  sim_id = 1:length(sigma_exp.block_list),
  sigma_block = sigma_exp.block_list,
  sigma_exp.block.treat_matrix,
  sigma_ss = sigma_ss_list
)

res_table <- matrix(as.numeric(NA), nrow = nrow(param_set_matrix), ncol = 15)
sim_table <- data.table(NULL)
big_table <- data.table(NULL)

if(do_sim == TRUE){
  for(param_set in 1:nrow(param_set_matrix)){
    sigma_exp.block_i <- param_set_matrix[param_set, sigma_block]
    sigma_exp.block.treat_i <- param_set_matrix[param_set, .SD, .SDcols = treatment_levels] %>% as.numeric()
    sigma_ss_i <- param_set_matrix[param_set, sigma_ss]
    sigma_rep_i <- 0.1
    sigma_exp.treat_i <- 0
    sigma_exp_i <- 0
    n_treat_i <- 3
    n_block_i <- 10
    n_rep_i <- 1
    n_ss_i <- 1
    fake_rcbd <- simulator(
      seed_i = seed_starter,
      n_sim = n_sims,
      n_treat = n_treat_i, # number of treatment levels
      n_block = n_block_i, # number of litters (blocks)
      n_rep = n_rep_i, # number of mice per litter:treatment
      n_ss = n_ss_i, # number of subsamples
      design = "rcbd",
      correlated_slopes = FALSE, # TRUE uses random int/slope model to generate data
      beta = beta_i,
      gamma = c(1, 1, 0), # sd of random intercept and slopes for non-ref
      rho = 0.0, # r between random intercept and slopes
      sigma_exp = sigma_exp_i, # sd among experiments
      sigma_exp.block = sigma_exp.block_i, # sd among exp:block (or block if n_exp = 1)
      sigma_exp.treat = sigma_exp.treat_i, # sd among exp:treat
      sigma_exp.block.treat = sigma_exp.block.treat_i, # sd among exp:block:treat
      sigma_rep = sigma_rep_i,
      sigma_ss = sigma_ss_i, # sd among subsamples within replication of treatment:block
      # sigma_exp = 0, # sd among experiments
      # sigma_exp.block = 0.1, # sd among exp:block (or block if n_exp = 1)
      # sigma_exp.treat = 0, # sd among exp:treat
      # sigma_exp.block.treat = c(0.1, 0.1, 0.1), # sd among exp:block:treat
      # sigma_rep = 0.1,
      # sigma_ss = 1, # sd among subsamples within replication of treatment:block
      block_name = "experiment",
      rep_name = "mouse",
      ss_name = "ss",
    )
    
    for(i in 1:n_sims){
      
      # models
      form_lm0 <- paste(paste0("sim_", i), "~ treatment") %>%
        formula()
      form_lm1 <- paste(paste0("sim_", i), "~ treatment + experiment") %>%
        formula()
      form_aov <- paste(paste0("sim_", i), "~ treatment + (treatment | experiment)") %>%
        formula()
      lm0 <- lm(form_lm0, data = fake_rcbd)
      lm1 <- lm(form_lm1, data = fake_rcbd)
      lmm2 <- lme(form_lm0,
                  random = ~1 | experiment,
                  correlation = corSymm(form = ~ 1 | experiment),
                  weights = varIdent(form = ~ 1 | treatment),
                  data = fake_rcbd) %>%
        try()
      if(inherits(lmm2, "try-error")){
        lmm2 <- NULL
      }
      
      # aov2 used for both multivariate (aov1) and univariate (aov2)
      aov2 <- aov_4(form_aov,
                    fun_aggregate = mean,
                    include_aov = TRUE,
                    data = fake_rcbd)
      fake_rcbd_means <- fake_rcbd[, .(sim_1 = mean(get(paste0("sim_", i)))),
                                     by = .(treatment, experiment)]
      
      pptt_pairs <- pairwise_t_tests(y_col = "sim_1",
                              g_col = "treatment",
                              id_col = "experiment",
                              data = fake_rcbd_means)
      
      lm0_pairs <- emmeans(lm0, specs = "treatment") %>%
        contrast(method = "revpairwise", adjust = "none")
      lm1_pairs <- emmeans(lm1, specs = "treatment") %>%
        contrast(method = "revpairwise", adjust = "none")
      aov1_pairs <- emmeans(aov2, specs = "treatment", model = "multivariate") %>%
        contrast(method = "revpairwise", adjust = "none")
      aov2_pairs <- emmeans(aov2, specs = "treatment", model = "univariate") %>%
        contrast(method = "revpairwise", adjust = "none")
      
      fake_rcbd[, y_res := residuals(lm0)]
      fake_rcbd_wide <- dcast(fake_rcbd,
                               experiment + rep ~ treatment,
                               value.var = "y_res")
      residual_correlations <- cor(fake_rcbd_wide[, .SD, .SDcols = treatment_levels])
      r_mat[i, 1] <- residual_correlations[2,1]
      r_mat[i, 2] <- residual_correlations[3,1]
      r_mat[i, 3] <- residual_correlations[3,2]
      
      lm0_p <- summary(lm0_pairs)[, "p.value"]
      lm1_p <- summary(lm1_pairs)[, "p.value"]
      aov1_p <- summary(aov1_pairs)[, "p.value"]
      aov2_p <- summary(aov2_pairs)[, "p.value"]
      pptt_p <- pptt_pairs[, p.value]
      
      p1_mat[i, 1] <- lm0_p[1]
      p1_mat[i, 2] <- lm1_p[1]
      p1_mat[i, 3] <- aov1_p[1]
      p1_mat[i, 4] <- aov2_p[1]
      p1_mat[i, 5] <- pptt_p[1]
      
      p2_mat[i, 1] <- lm0_p[2]
      p2_mat[i, 2] <- lm1_p[2]
      p2_mat[i, 3] <- aov1_p[2]
      p2_mat[i, 4] <- aov2_p[2]
      p2_mat[i, 5] <- pptt_p[2]
      
      p3_mat[i, 1] <- lm0_p[3]
      p3_mat[i, 2] <- lm1_p[3]
      p3_mat[i, 3] <- aov1_p[3]
      p3_mat[i, 4] <- aov2_p[3]
      p3_mat[i, 5] <- pptt_p[3]
      
      if(!is.null(lmm2)){
        lmm2_pairs <- emmeans(lmm2, specs = "treatment") %>%
          contrast(method = "revpairwise", adjust = "none")
        p1_mat[i, 6] <- summary(lmm2_pairs)[1, "p.value"]
        p2_mat[i, 6] <- summary(lmm2_pairs)[2, "p.value"]
        p3_mat[i, 6] <- summary(lmm2_pairs)[3, "p.value"]
      }else{
        p1_mat[i, 6] <- lm1_p[1]
        p2_mat[i, 6] <- lm1_p[2]
        p3_mat[i, 6] <- lm1_p[3]
      }

      
    }
    
    sim_table <- cbind(r_mat, p1_mat, p2_mat, p3_mat)
    sim_table_names <- paste(rep(model_levels, 3),
          rep(c("contrast_1", "contrast_2", "contrast_3"), each = length(model_levels)),
          sep = "_")
    colnames(sim_table) <- c("r21", "r31", "r32", sim_table_names)
    
    big_table <- rbind(
      big_table,
      data.table(
        sim_id = param_set,
        n_treat = n_treat_i,
        n_block = n_block_i,
        n_rep = n_rep_i,
        n_ss = n_ss_i,
        sigma_block = sigma_exp.block_i,
        sigma_block.treat_1 = sigma_exp.block.treat_i[1],
        sigma_block.treat_2 = sigma_exp.block.treat_i[2],
        sigma_block.treat_3 = sigma_exp.block.treat_i[3],
        sigma_exp.treat = sigma_exp.treat_i,
        sigma_rep = sigma_rep_i,
        sigma_exp = sigma_exp_i,
        sigma_ss = sigma_ss_i,
        sim_table
      )
    )
  } # end sim
  
  data_from <- "rmd - projects/grcbds/data"
  outfile_name <- "rcbd.Rds"
  save_file_path <- here(data_from, outfile_name)
  saveRDS(object = big_table, file = save_file_path)
  
}else{
  data_from <- "rmd - projects/grcbds/data"
  outfile_name <- "rcbd.Rds"
  save_file_path <- here(data_from, outfile_name)
  big_table <- readRDS(save_file_path)
} # end do_sim


out_table <- data.table(NULL)
for(param_set in 1:nrow(param_set_matrix)){
  r_mat <- big_table[sim_id == param_set, .SD, .SDcols = c("r21", "r31", "r32")]
  p1_mat <- big_table[sim_id == param_set, .SD, .SDcols = paste0(model_levels, "_contrast_1")]
  p2_mat <- big_table[sim_id == param_set, .SD, .SDcols = paste0(model_levels, "_contrast_2")]
  p3_mat <- big_table[sim_id == param_set, .SD, .SDcols = paste0(model_levels, "_contrast_3")]
  out_table <- rbind(
    out_table,
    data.table(
      contrast = c("Cn, Tr1", "Cn, Tr2", "Tr1, Tr2"),
      cor = apply(r_mat, 2, mean),
      rbind(apply(p1_mat, 2, pless),
            apply(p2_mat, 2, pless),
            apply(p3_mat, 2, pless))
    ))
}

setnames(out_table,
         names(out_table),
         c("Contrast", "Cor Error", model_levels))
out_table %>%
  kable(digits = c(1, 3, 3, 3, 3, 3, 3, 4), caption = "models") %>%
  kable_styling() %>%
  pack_rows("sim 1 - high correlated error", 1, 3) %>%
  pack_rows("sim 2 - low correlated error", 4, 6) %>%
  pack_rows("sim 3 - equal correlated error", 7, 9) %>%
  pack_rows("sim 4 - zero correlated error", 10, 12)

```

## GRCBD
### Balanced

**The experimental design**

1. The design is GRCBD. There are 10 blocks, each with 3 treatment levels. There are 2 replicates of each treatment in each block. Examples are
    * Six mice are sampled from 10 litters. Within each litter, 2 are assigned to Cn, 2 to Tr1, and 2 to Tr2. Litter is the block.
    * 6 cultures are randomly assigned to 2 Cn, 2 Tr1, and 2 Tr2. The experiment is replicated 10 times. Experiment is the block.
2. The design is balanced.

**The simulation**

1. Simulation performance is measured as the Type I error rate ("size")
2. Four scenarios are simulated
    * Moderate correlated error. Heterogenous variance and correlation (unstructured error covariance)
    * Small correlated error. Heterogenous variance and correlation (unstructured error covariance)
    * Moderate correlated error. Homogenous variance and correlation (compound symmetry error covariance)
    * No correlated error. Homogenous variance (standard lm assumptions)

**The models**

1. lm0: linear model with treatment as the single factor
2. lm1: fixed effect model; treatment * block
3. aov1: multivariate repeated measures ANOVA
4. aov2: univariate repeated measures ANOVA
5. pptt: pairwise, paired t-test

Notes on models

1. lmm3 (random intercept and slope) is not simulated because the inference is the same as aov1, which is quicker
2. lmm4 (random interaction intercept, aka split plot model) is not simulated because the inference is the same as aov2, which is quicker
3. pptt has same inference as aov1 but including it

```{r grcbd-performance-sim, warning=FALSE, message=FALSE, error=FALSE}
set.seed(1)
n_sims <- 2000
do_sim <- FALSE

param_sets <- 3
treatment_levels <- c("Cn", "Tr1", "Tr2")
model_levels <- c("lm0", "lm1", "aov1", "aov2", "pptt")
  
p1_mat <- matrix(as.numeric(NA), nrow = n_sims, ncol = length(model_levels))
p2_mat <- matrix(as.numeric(NA), nrow = n_sims, ncol = length(model_levels))
p3_mat <- matrix(as.numeric(NA), nrow = n_sims, ncol = length(model_levels))
r_mat <- matrix(as.numeric(NA), nrow = n_sims, ncol = 3)

# parameters
beta_i = c(10, 0, 0)

# each row is different param_set
sigma_exp.block.treat_matrix <- matrix(c(
  c(2, 1, 0.2),
  c(0.5, .25, 0.05),
  c(0, 0, 0),
  c(0, 0, 0)
), nrow = 3, ncol = 4) %>%
  t()
colnames(sigma_exp.block.treat_matrix) <- treatment_levels

# each value is different param_set
sigma_exp.block_list <- c(1, 0.25, 0.8, 0)

# each value is different param_set
sigma_ss_list <- c(.1, .4, .4, 1)

param_set_matrix <- data.table(
  sim_id = 1:length(sigma_exp.block_list),
  sigma_block = sigma_exp.block_list,
  sigma_exp.block.treat_matrix,
  sigma_ss = sigma_ss_list
)

res_table <- matrix(as.numeric(NA), nrow = nrow(param_set_matrix), ncol = 15)
sim_table <- data.table(NULL)
big_table <- data.table(NULL)

if(do_sim == TRUE){
  for(param_set in 1:nrow(param_set_matrix)){
    sigma_exp.block_i <- param_set_matrix[param_set, sigma_block]
    sigma_exp.block.treat_i <- param_set_matrix[param_set, .SD, .SDcols = treatment_levels] %>% as.numeric()
    sigma_ss_i <- param_set_matrix[param_set, sigma_ss]
    sigma_rep_i <- 0.1
    sigma_exp.treat_i <- 0
    sigma_exp_i <- 0
    n_treat_i <- 3
    n_block_i <- 10
    n_rep_i <- 2
    n_ss_i <- 1
    fake_grcbd <- simulator(
      seed_i = seed_starter,
      n_sim = n_sims,
      n_treat = n_treat_i, # number of treatment levels
      n_block = n_block_i, # number of litters (blocks)
      n_rep = n_rep_i, # number of mice per litter:treatment
      n_ss = n_ss_i, # number of subsamples
      design = "rcbd",
      correlated_slopes = FALSE, # TRUE uses random int/slope model to generate data
      beta = beta_i,
      gamma = c(1, 1, 0), # sd of random intercept and slopes for non-ref
      rho = 0.0, # r between random intercept and slopes
      sigma_exp = sigma_exp_i, # sd among experiments
      sigma_exp.block = sigma_exp.block_i, # sd among exp:block (or block if n_exp = 1)
      sigma_exp.treat = sigma_exp.treat_i, # sd among exp:treat
      sigma_exp.block.treat = sigma_exp.block.treat_i, # sd among exp:block:treat
      sigma_rep = sigma_rep_i,
      sigma_ss = sigma_ss_i, # sd among subsamples within replication of treatment:block
      # sigma_exp = 0, # sd among experiments
      # sigma_exp.block = 0.1, # sd among exp:block (or block if n_exp = 1)
      # sigma_exp.treat = 0, # sd among exp:treat
      # sigma_exp.block.treat = c(0.1, 0.1, 0.1), # sd among exp:block:treat
      # sigma_rep = 0.1,
      # sigma_ss = 1, # sd among subsamples within replication of treatment:block
      block_name = "experiment",
      rep_name = "mouse",
      ss_name = "ss",
    )
    
    for(i in 1:n_sims){
      
      # models
      form_lm0 <- paste(paste0("sim_", i), "~ treatment") %>%
        formula()
      form_lm1 <- paste(paste0("sim_", i), "~ treatment + experiment") %>%
        formula()
      form_aov <- paste(paste0("sim_", i), "~ treatment + (treatment | experiment)") %>%
        formula()
      lm0 <- lm(form_lm0, data = fake_grcbd)
      lm1 <- lm(form_lm1, data = fake_grcbd)
      # aov2 used for both multivariate (aov1) and univariate (aov2)
      aov2 <- aov_4(form_aov,
                    fun_aggregate = mean,
                    include_aov = TRUE,
                    data = fake_grcbd)
      fake_grcbd_means <- fake_grcbd[, .(sim_1 = mean(get(paste0("sim_", i)))),
                                     by = .(treatment, experiment)]
      
      pptt_pairs <- pairwise_t_tests(y_col = "sim_1",
                              g_col = "treatment",
                              id_col = "experiment",
                              data = fake_grcbd_means)
      
      lm0_pairs <- emmeans(lm0, specs = "treatment") %>%
        contrast(method = "revpairwise", adjust = "none")
      lm1_pairs <- emmeans(lm1, specs = "treatment") %>%
        contrast(method = "revpairwise", adjust = "none")
      aov1_pairs <- emmeans(aov2, specs = "treatment", model = "multivariate") %>%
        contrast(method = "revpairwise", adjust = "none")
      aov2_pairs <- emmeans(aov2, specs = "treatment", model = "univariate") %>%
        contrast(method = "revpairwise", adjust = "none")
      
      fake_grcbd[, y_res := residuals(lm0)]
      fake_grcbd_wide <- dcast(fake_grcbd,
                               experiment + rep ~ treatment,
                               value.var = "y_res")
      residual_correlations <- cor(fake_grcbd_wide[, .SD, .SDcols = treatment_levels])
      r_mat[i, 1] <- residual_correlations[2,1]
      r_mat[i, 2] <- residual_correlations[3,1]
      r_mat[i, 3] <- residual_correlations[3,2]
      
      lm0_p <- summary(lm0_pairs)[, "p.value"]
      lm1_p <- summary(lm1_pairs)[, "p.value"]
      aov1_p <- summary(aov1_pairs)[, "p.value"]
      aov2_p <- summary(aov2_pairs)[, "p.value"]
      pptt_p <- pptt_pairs[, p.value]
      
      p1_mat[i, 1] <- lm0_p[1]
      p1_mat[i, 2] <- lm1_p[1]
      p1_mat[i, 3] <- aov1_p[1]
      p1_mat[i, 4] <- aov2_p[1]
      p1_mat[i, 5] <- pptt_p[1]
      
      p2_mat[i, 1] <- lm0_p[2]
      p2_mat[i, 2] <- lm1_p[2]
      p2_mat[i, 3] <- aov1_p[2]
      p2_mat[i, 4] <- aov2_p[2]
      p2_mat[i, 5] <- pptt_p[2]
      
      p3_mat[i, 1] <- lm0_p[3]
      p3_mat[i, 2] <- lm1_p[3]
      p3_mat[i, 3] <- aov1_p[3]
      p3_mat[i, 4] <- aov2_p[3]
      p3_mat[i, 5] <- pptt_p[3]
      
    }
    
    sim_table <- cbind(r_mat, p1_mat, p2_mat, p3_mat)
    sim_table_names <- paste(rep(model_levels, 3),
          rep(c("contrast_1", "contrast_2", "contrast_3"), each = length(model_levels)),
          sep = "_")
    colnames(sim_table) <- c("r21", "r31", "r32", sim_table_names)
    
    big_table <- rbind(
      big_table,
      data.table(
        sim_id = param_set,
        n_treat = n_treat_i,
        n_block = n_block_i,
        n_rep = n_rep_i,
        n_ss = n_ss_i,
        sigma_block = sigma_exp.block_i,
        sigma_block.treat_1 = sigma_exp.block.treat_i[1],
        sigma_block.treat_2 = sigma_exp.block.treat_i[2],
        sigma_block.treat_3 = sigma_exp.block.treat_i[3],
        sigma_exp.treat = sigma_exp.treat_i,
        sigma_rep = sigma_rep_i,
        sigma_exp = sigma_exp_i,
        sigma_ss = sigma_ss_i,
        sim_table
      )
    )
  } # end sim
  
  data_from <- "rmd - projects/grcbds/data"
  outfile_name <- "grcbd.Rds"
  save_file_path <- here(data_from, outfile_name)
  saveRDS(object = big_table, file = save_file_path)
  
}else{
  data_from <- "rmd - projects/grcbds/data"
  outfile_name <- "grcbd.Rds"
  save_file_path <- here(data_from, outfile_name)
  big_table <- readRDS(save_file_path)
} # end do_sim


out_table <- data.table(NULL)
for(param_set in 1:nrow(param_set_matrix)){
  r_mat <- big_table[sim_id == param_set, .SD, .SDcols = c("r21", "r31", "r32")]
  p1_mat <- big_table[sim_id == param_set, .SD, .SDcols = paste0(model_levels, "_contrast_1")]
  p2_mat <- big_table[sim_id == param_set, .SD, .SDcols = paste0(model_levels, "_contrast_2")]
  p3_mat <- big_table[sim_id == param_set, .SD, .SDcols = paste0(model_levels, "_contrast_3")]
  out_table <- rbind(
    out_table,
    data.table(
      contrast = c("Cn, Tr1", "Cn, Tr2", "Tr1, Tr2"),
      cor = apply(r_mat, 2, mean),
      rbind(apply(p1_mat, 2, pless),
            apply(p2_mat, 2, pless),
            apply(p3_mat, 2, pless))
    ))
}

setnames(out_table,
         names(out_table),
         c("Contrast", "Cor Error", model_levels))
out_table %>%
  kable(digits = c(1, 3, 3, 3, 3, 3, 3, 4), caption = "models") %>%
  kable_styling() %>%
  pack_rows("sim 1 - high correlated error", 1, 3) %>%
  pack_rows("sim 2 - low correlated error", 4, 6) %>%
  pack_rows("sim 3 - equal correlated error", 7, 9) %>%
  pack_rows("sim 4 - zero correlated error", 10, 12)

```

### Unbalanced

**The experimental design**

1. The design is GRCBD. There are 10 blocks, each with 3 treatment levels. There are 2 replicates of each treatment in each block. Examples are
    * Six mice are sampled from 10 litters. Within each litter, 2 are assigned to Cn, 2 to Tr1, and 2 to Tr2. Litter is the block.
    * 6 cultures are randomly assigned to 2 Cn, 2 Tr1, and 2 Tr2. The experiment is replicated 10 times. Experiment is the block.
2. The design is unbalanced. Both Cn treatments from block 1 are missing. aov1 and aov2 will exclude this whole block. pairwise paired-t tests will only exclude block 1 in the comparisons that include Cn. lmm3 will use all information.

**The simulation**

1. Simulation performance is measured as Power (1 - Type II error rate)
2. Four scenarios are simulated
    * Moderate correlated error. Heterogenous variance and correlation (unstructured error covariance)
    * Small correlated error. Heterogenous variance and correlation (unstructured error covariance)
    * Moderate correlated error. Homogenous variance and correlation (compound symmetry error covariance)
    * No correlated error. Homogenous variance (standard lm assumptions)

**The models**

1. lm0: linear model with treatment as the single factor
2. lm1: fixed effect model; treatment * block
3. aov1: multivariate repeated measures ANOVA
4. aov2: univariate repeated measures ANOVA
5. pptt: pairwise, paired t-test
6. lmm3: random slope and intercept model

Notes on models

1. lmm3 (random intercept and slope) is not simulated because the inference is the same as aov1, which is quicker
2. lmm4 (random interaction intercept, aka split plot model) is not simulated because the inference is the same as aov2, which is quicker
3. aov1, pptt, and lmm3 will have slightly different inference because of unbalance

```{r grcbd-performance-sim-unbalanced, warning=FALSE, message=FALSE, error=FALSE}
set.seed(1)
n_sims <- 2000
do_sim <- FALSE

param_sets <- 3
treatment_levels <- c("Cn", "Tr1", "Tr2")
model_levels <- c("lm0", "lm1", "aov1", "aov2", "pptt", "lmm3")
  
p1_mat <- matrix(as.numeric(NA), nrow = n_sims, ncol = length(model_levels))
p2_mat <- matrix(as.numeric(NA), nrow = n_sims, ncol = length(model_levels))
p3_mat <- matrix(as.numeric(NA), nrow = n_sims, ncol = length(model_levels))
r_mat <- matrix(as.numeric(NA), nrow = n_sims, ncol = 3)

# parameters
beta_i = c(10, 0.25, 0.5)
# each row is different param_set
beta_matrix <- matrix(c(
  c(10, 1, 2),
  c(10, 0.4, 0.8),
  c(10, 0.25, 0.5),
  c(10, 0.6, 1.2)
), nrow = 3, ncol = 4) %>%
  t()
beta_cols <- c("beta_0", "beta_1", "beta_2")
colnames(beta_matrix) <- beta_cols

# each row is different param_set
sigma_exp.block.treat_matrix <- matrix(c(
  c(2, 1, 0.2),
  c(0.5, .25, 0.05),
  c(0, 0, 0),
  c(0, 0, 0)
), nrow = 3, ncol = 4) %>%
  t()
colnames(sigma_exp.block.treat_matrix) <- treatment_levels

# each value is different param_set
sigma_exp.block_list <- c(1, 0.25, 0.8, 0)

# each value is different param_set
sigma_ss_list <- c(.1, .4, .4, 1)

param_set_matrix <- data.table(
  sim_id = 1:length(sigma_exp.block_list),
  beta_matrix,
  sigma_block = sigma_exp.block_list,
  sigma_exp.block.treat_matrix,
  sigma_ss = sigma_ss_list
)

res_table <- matrix(as.numeric(NA), nrow = nrow(param_set_matrix), ncol = 15)
sim_table <- data.table(NULL)
big_table <- data.table(NULL)

if(do_sim == TRUE){
  for(param_set in 1:nrow(param_set_matrix)){
    beta_i = param_set_matrix[param_set, .SD, .SDcols = beta_cols] %>% as.numeric()
    sigma_exp.block_i <- param_set_matrix[param_set, sigma_block]
    sigma_exp.block.treat_i <- param_set_matrix[param_set, .SD, .SDcols = treatment_levels] %>% as.numeric()
    sigma_ss_i <- param_set_matrix[param_set, sigma_ss]
    sigma_rep_i <- 0.1
    sigma_exp.treat_i <- 0
    sigma_exp_i <- 0
    n_treat_i <- 3
    n_block_i <- 10
    n_rep_i <- 2
    n_ss_i <- 1
    fake_grcbd <- simulator(
      seed_i = seed_starter,
      n_sim = n_sims,
      n_treat = n_treat_i, # number of treatment levels
      n_block = n_block_i, # number of litters (blocks)
      n_rep = n_rep_i, # number of mice per litter:treatment
      n_ss = n_ss_i, # number of subsamples
      design = "rcbd",
      beta = beta_i,
      sigma_exp = sigma_exp_i, # sd among experiments
      sigma_exp.block = sigma_exp.block_i, # sd among exp:block (or block if n_exp = 1)
      sigma_exp.treat = sigma_exp.treat_i, # sd among exp:treat
      sigma_exp.block.treat = sigma_exp.block.treat_i, # sd among exp:block:treat
      sigma_rep = sigma_rep_i,
      sigma_ss = sigma_ss_i, # sd among subsamples within replication of treatment:block
      block_name = "experiment",
      rep_name = "mouse",
      ss_name = "ss",
    )
    
    # create missing
    inc <- 3:nrow(fake_grcbd) # remove treatment "Cn" from experiment 1
    fake_grcbd <- fake_grcbd[inc]
    for(i in 1:n_sims){
      # models
      form_lm0 <- paste(paste0("sim_", i), "~ treatment") %>%
        formula()
      form_lm1 <- paste(paste0("sim_", i), "~ treatment + experiment") %>%
        formula()
      form_lmm <- paste(paste0("sim_", i), "~ treatment + (treatment | experiment)") %>%
        formula()
      lm0 <- lm(form_lm0, data = fake_grcbd)
      lm1 <- lm(form_lm1, data = fake_grcbd)
      lmm3 <- lmer(form_lmm,
                   data = fake_grcbd)
      lmer_message <- ifelse(is.null(lmer_check(lmm3)),
                             "none",
                             "error")
      # aov1 used for both multivariate (aov1) and univariate (aov2)
      aov1 <- aov_4(form_lmm,
                    fun_aggregate = mean,
                    include_aov = TRUE,
                    data = fake_grcbd)
      fake_grcbd_means <- fake_grcbd[, .(sim_1 = mean(get(paste0("sim_", i)))),
                                     by = .(treatment, experiment)]
      
      pptt_pairs <- pairwise_t_tests(y_col = "sim_1",
                              g_col = "treatment",
                              id_col = "experiment",
                              data = fake_grcbd_means)
      
      lm0_pairs <- emmeans(lm0, specs = "treatment") %>%
        contrast(method = "revpairwise", adjust = "none")
      lm1_pairs <- emmeans(lm1, specs = "treatment") %>%
        contrast(method = "revpairwise", adjust = "none")
      lmm3_pairs <- emmeans(lmm3, specs = "treatment") %>%
        contrast(method = "revpairwise", adjust = "none")
      aov1_pairs <- emmeans(aov1, specs = "treatment", model = "multivariate") %>%
        contrast(method = "revpairwise", adjust = "none")
      aov2_pairs <- emmeans(aov1, specs = "treatment", model = "univariate") %>%
        contrast(method = "revpairwise", adjust = "none")
      
      fake_grcbd[, y_res := residuals(lm0)]
      fake_grcbd_wide <- dcast(fake_grcbd,
                               experiment + rep ~ treatment,
                               value.var = "y_res")
      residual_correlations <- cor(fake_grcbd_wide[, .SD, .SDcols = treatment_levels], use = "pairwise.complete.obs")
      r_mat[i, 1] <- residual_correlations[2,1]
      r_mat[i, 2] <- residual_correlations[3,1]
      r_mat[i, 3] <- residual_correlations[3,2]
      
      lm0_p <- summary(lm0_pairs)[, "p.value"]
      lm1_p <- summary(lm1_pairs)[, "p.value"]
      if(lmer_message == "none"){
        lmm3_p <- summary(lmm3_pairs)[, "p.value"]
      }else{
        lmm3_p <- pptt_pairs[, p.value] # lmer then paired t strategy
      }
      aov1_p <- summary(aov1_pairs)[, "p.value"]
      aov2_p <- summary(aov2_pairs)[, "p.value"]
      pptt_p <- pptt_pairs[, p.value]
      
      p1_mat[i, 1] <- lm0_p[1]
      p1_mat[i, 2] <- lm1_p[1]
      p1_mat[i, 3] <- aov1_p[1]
      p1_mat[i, 4] <- aov2_p[1]
      p1_mat[i, 5] <- pptt_p[1]
      p1_mat[i, 6] <- lmm3_p[1]
      
      p2_mat[i, 1] <- lm0_p[2]
      p2_mat[i, 2] <- lm1_p[2]
      p2_mat[i, 3] <- aov1_p[2]
      p2_mat[i, 4] <- aov2_p[2]
      p2_mat[i, 5] <- pptt_p[2]
      p2_mat[i, 6] <- lmm3_p[2]
      
      p3_mat[i, 1] <- lm0_p[3]
      p3_mat[i, 2] <- lm1_p[3]
      p3_mat[i, 3] <- aov1_p[3]
      p3_mat[i, 4] <- aov2_p[3]
      p3_mat[i, 5] <- pptt_p[3]
      p3_mat[i, 6] <- lmm3_p[3]
      
    }
    
    sim_table <- cbind(r_mat, p1_mat, p2_mat, p3_mat)
    sim_table_names <- paste(rep(model_levels, 3),
          rep(c("contrast_1", "contrast_2", "contrast_3"), each = length(model_levels)),
          sep = "_")
    colnames(sim_table) <- c("r21", "r31", "r32", sim_table_names)
    
    big_table <- rbind(
      big_table,
      data.table(
        sim_id = param_set,
        n_treat = n_treat_i,
        n_block = n_block_i,
        n_rep = n_rep_i,
        n_ss = n_ss_i,
        sigma_block = sigma_exp.block_i,
        sigma_block.treat_1 = sigma_exp.block.treat_i[1],
        sigma_block.treat_2 = sigma_exp.block.treat_i[2],
        sigma_block.treat_3 = sigma_exp.block.treat_i[3],
        sigma_exp.treat = sigma_exp.treat_i,
        sigma_rep = sigma_rep_i,
        sigma_exp = sigma_exp_i,
        sigma_ss = sigma_ss_i,
        sim_table
      )
    )
  } # end sim
  
  data_from <- "rmd - projects/grcbds/data"
  outfile_name <- "grcbd_unbalanced.Rds"
  save_file_path <- here(data_from, outfile_name)
  saveRDS(object = big_table, file = save_file_path)
  
}else{
  data_from <- "rmd - projects/grcbds/data"
  outfile_name <- "grcbd_unbalanced.Rds"
  save_file_path <- here(data_from, outfile_name)
  big_table <- readRDS(save_file_path)
} # end do_sim


out_table <- data.table(NULL)
for(param_set in 1:nrow(param_set_matrix)){
  r_mat <- big_table[sim_id == param_set, .SD, .SDcols = c("r21", "r31", "r32")]
  p1_mat <- big_table[sim_id == param_set, .SD, .SDcols = paste0(model_levels, "_contrast_1")]
  p2_mat <- big_table[sim_id == param_set, .SD, .SDcols = paste0(model_levels, "_contrast_2")]
  p3_mat <- big_table[sim_id == param_set, .SD, .SDcols = paste0(model_levels, "_contrast_3")]
  out_table <- rbind(
    out_table,
    data.table(
      contrast = c("Cn, Tr1", "Cn, Tr2", "Tr1, Tr2"),
      cor = apply(r_mat, 2, mean),
      rbind(apply(p1_mat, 2, pless),
            apply(p2_mat, 2, pless),
            apply(p3_mat, 2, pless))
    ))
}

setnames(out_table,
         names(out_table),
         c("Contrast", "Cor Error", model_levels))
out_table %>%
  kable(digits = c(1, 3, 3, 3, 3, 3, 3, 4), caption = "models") %>%
  kable_styling() %>%
  pack_rows("sim 1 - high correlated error", 1, 3) %>%
  pack_rows("sim 2 - low correlated error", 4, 6) %>%
  pack_rows("sim 3 - equal correlated error", 7, 9) %>%
  pack_rows("sim 4 - zero correlated error", 10, 12)


```


```{r output-as-R-file}
# highlight and run to put update into R folder
# knitr::purl("grcbds.Rmd")
```

